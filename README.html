<!DOCTYPE html>
<html>

<head>
    <meta charset="UTF-8">
    <title>Monoceros</title>
    <style>

    </style>

    <link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/Microsoft/vscode/extensions/markdown-language-features/media/markdown.css">
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/Microsoft/vscode/extensions/markdown-language-features/media/highlight.css">
    <style>
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe WPC', 'Segoe UI', system-ui, 'Ubuntu', 'Droid Sans', sans-serif;
            font-size: 14px;
            line-height: 1.6;
        }
    </style>
    <style>
        .task-list-item {
            list-style-type: none;
        }
        
        .task-list-item-checkbox {
            margin-left: -20px;
            vertical-align: middle;
        }
    </style>



</head>

<body class="vscode-body vscode-light">
    <h1 id="monoceros">Monoceros</h1>
    <p><img src="./readme-assets/monoceros32.png" alt="Monoceros">
        <strong>Monoceros</strong>: a Wave Function Collapse plug-in for Grasshopper by Subdigital
    </p>
    <h2 id="1-authors">1. Authors</h2>
    <ul>
        <li>Ján Pernecký: <a href="mailto:jan@sub.digital">jan@sub.digital</a></li>
        <li>Ján Tóth: <a href="mailto:yanchi.toth@gmail.com">yanchi.toth@gmail.com</a>,
            <a href="https://yanchith.github.io">yanchith</a>, <a href="https://github.com/yanchith">GitHub</a>
        </li>
        <li><strong>Subdigital</strong>: <a href="https://www.sub.digtial">sub.digital</a>,
            <a href="https://github.com/subdgtl">GitHub</a>
        </li>
    </ul>
    <h2 id="2-tldr">2. Tl;dr</h2>
    <p><strong>Monoceros is a Grasshopper plug-in that fills the entire world with Modules,
            respecting the given Rules.</strong></p>
    <h2 id="3-table-of-contents">3. Table of contents</h2>
    <ul>
        <li><a href="#1-authors">1. Authors</a></li>
        <li><a href="#2-tldr">2. Tl;dr</a></li>
        <li><a href="#3-table-of-contents">3. Table of contents</a></li>
        <li><a href="#4-meet-monoceros">4. Meet Monoceros</a></li>
        <li><a href="#5-wave-function-collapse">5. Wave Function Collapse</a></li>
        <li><a href="#6-development-notes">6. Development notes</a></li>
        <li><a href="#7-architecture-of-monoceros-grasshopper-plug-in">7. Architecture of Monoceros Grasshopper
                plug-in</a></li>
        <li><a href="#8-data-types">8. Data types</a>
            <ul>
                <li><a href="#81-slot">8.1. Slot</a>
                    <ul>
                        <li><a href="#811-states">8.1.1. States</a></li>
                        <li><a href="#812-slot-properties">8.1.2. Slot Properties</a></li>
                        <li><a href="#813-automatic-envelope-wrapping">8.1.3. Automatic Envelope wrapping</a></li>
                        <li><a href="#814-modules-and-their-parts">8.1.4. Modules and their Parts</a></li>
                        <li><a href="#815-viewport-preview-and-baking">8.1.5. Viewport preview and baking</a></li>
                        <li><a href="#816-slot-casts-to">8.1.6. Slot casts to</a></li>
                    </ul>
                </li>
                <li><a href="#82-module">8.2. Module</a>
                    <ul>
                        <li><a href="#821-monoceros-module-parts">8.2.1. Monoceros Module Parts</a></li>
                        <li><a href="#822-connectors">8.2.2. Connectors</a></li>
                        <li><a href="#823-module-geometry">8.2.3. Module Geometry</a></li>
                        <li><a href="#824-orientation-and-placement">8.2.4. Orientation and placement</a></li>
                        <li><a href="#825-module-properties">8.2.5. Module Properties</a></li>
                        <li><a href="#826-special-modules-out-and-empty">8.2.6. Special Modules: Out and Empty</a></li>
                        <li><a href="#827-viewport-preview-and-baking">8.2.7. Viewport preview and baking</a></li>
                        <li><a href="#828-module-casts">8.2.8. Module casts</a></li>
                    </ul>
                </li>
                <li><a href="#83-rule">8.3. Rule</a>
                    <ul>
                        <li><a href="#831-explicit-rule">8.3.1. Explicit Rule</a>
                            <ul>
                                <li><a href="#8311-explicit-rule-properties">8.3.1.1. Explicit Rule properties</a></li>
                                <li><a href="#8312-explicit-rule-casts">8.3.1.2. Explicit Rule casts</a></li>
                                <li><a href="#8313-explicit-rule-viewport-preview-and-baking">8.3.1.3. Explicit Rule
                                        Viewport preview and baking</a></li>
                            </ul>
                        </li>
                        <li><a href="#832-typed-rule">8.3.2. Typed Rule</a>
                            <ul>
                                <li><a href="#8321-typed-rule-properties">8.3.2.1. Typed Rule properties</a></li>
                                <li><a href="#8322-typed-rule-casts">8.3.2.2. Typed Rule casts</a></li>
                                <li><a href="#8323-typed-rule-viewport-preview-and-baking">8.3.2.3. Typed Rule Viewport
                                        preview and baking</a></li>
                            </ul>
                        </li>
                        <li><a href="#833-indifferent-typed-rule">8.3.3. Indifferent Typed Rule</a></li>
                    </ul>
                </li>
            </ul>
        </li>
        <li><a href="#9-monoceros-wfc-solver">9. Monoceros WFC Solver</a>
            <ul>
                <li><a href="#91-rule-and-module-lowering">9.1. Rule and Module Lowering</a></li>
                <li><a href="#92-172-canonical-world-state">9.2. 1.7.2 Canonical World State</a></li>
            </ul>
        </li>
        <li><a href="#10-components">10. Components</a>
            <ul>
                <li><a href="#101-slot-related">10.1. Slot-related</a>
                    <ul>
                        <li><a href="#1011-construct-slot-with-all-modules-allowed">10.1.1. Construct Slot With All
                                Modules Allowed</a></li>
                        <li><a href="#1012-construct-slot-with-listed-modules-allowed">10.1.2. Construct Slot With
                                Listed Modules Allowed</a></li>
                        <li><a href="#1013-deconstruct-slot">10.1.3. Deconstruct Slot</a></li>
                        <li><a href="#1014-are-slots-boundary">10.1.4. Are Slots Boundary</a></li>
                        <li><a href="#1015-add-boundary-layer">10.1.5. Add Boundary Layer</a></li>
                    </ul>
                </li>
                <li><a href="#102-module-related">10.2. Module-related</a>
                    <ul>
                        <li><a href="#1021-construct-module">10.2.1. Construct Module</a></li>
                        <li><a href="#1022-construct-empty-module">10.2.2. Construct Empty Module</a></li>
                        <li><a href="#1023-deconstruct-module">10.2.3. Deconstruct Module</a></li>
                    </ul>
                </li>
                <li><a href="#103-rule-related">10.3. Rule-related</a>
                    <ul>
                        <li><a href="#1031-construct-explicit-rule">10.3.1. Construct Explicit Rule</a></li>
                        <li><a href="#1032-deconstruct-explicit-rule">10.3.2. Deconstruct Explicit Rule</a></li>
                        <li><a href="#1033-is-rule-explicit">10.3.3. Is Rule Explicit</a></li>
                        <li><a href="#1034-construct-typed-rule">10.3.4. Construct Typed Rule</a></li>
                        <li><a href="#1035-deconstruct-typed-rule">10.3.5. Deconstruct Typed Rule</a></li>
                        <li><a href="#1036-is-rule-typed">10.3.6. Is Rule Typed</a></li>
                        <li><a href="#1037-unwrap-typed-rules">10.3.7. Unwrap Typed Rules</a></li>
                        <li><a href="#1038-collect-rules">10.3.8. Collect Rules</a></li>
                        <li><a href="#1039-explicit-rule-from-curve">10.3.9. Explicit Rule From Curve</a></li>
                        <li><a href="#10310-typed-rule-from-point">10.3.10. Typed Rule From Point</a></li>
                        <li><a href="#10311-rule-at-boundary-from-point">10.3.11. Rule At Boundary From Point</a></li>
                        <li><a href="#10312-indifferent-rule-from-point">10.3.12. Indifferent Rule From Point</a></li>
                        <li><a href="#10313-indifferent-rules-for-unused-connectors">10.3.13. Indifferent Rules For
                                Unused Connectors</a></li>
                    </ul>
                </li>
                <li><a href="#104-solver">10.4. Solver</a>
                    <ul>
                        <li><a href="#1041-monoceros-wfc-solver">10.4.1. Monoceros WFC Solver</a></li>
                    </ul>
                </li>
                <li><a href="#105-post-processing">10.5. Post processing</a>
                    <ul>
                        <li><a href="#1051-materialize-slots">10.5.1. Materialize Slots</a></li>
                        <li><a href="#1052-assemble-rule">10.5.2. Assemble Rule</a></li>
                        <li><a href="#1053-rule-preview">10.5.3. Rule Preview</a></li>
                    </ul>
                </li>
                <li><a href="#106-supplemental">10.6. Supplemental</a>
                    <ul>
                        <li><a href="#1061-slice-geometry">10.6.1. Slice Geometry</a></li>
                    </ul>
                </li>
            </ul>
        </li>
        <li><a href="#11-examples">11. Examples</a>
            <ul>
                <li><a href="#111-bare-minimum">11.1. Bare minimum</a>
                    <ul>
                        <li><a href="#1111-pseudo-code">11.1.1. Pseudo code</a></li>
                        <li><a href="#1112-definition">11.1.2. Definition</a></li>
                        <li><a href="#1113-breakdown">11.1.3. Breakdown</a></li>
                    </ul>
                </li>
                <li><a href="#112-explicit-rules">11.2. Explicit Rules</a>
                    <ul>
                        <li><a href="#1121-definition-explicit-rule-from-a-literal">11.2.1. Definition: Explicit Rule
                                from a literal</a></li>
                        <li><a href="#1122-definition-explicit-rule-from-components">11.2.2. Definition: Explicit Rule
                                from components</a></li>
                        <li><a href="#1123-definition-explicit-rule-from-curve">11.2.3. Definition: Explicit Rule from
                                curve</a></li>
                    </ul>
                </li>
                <li><a href="#113-typed-rules">11.3. Typed Rules</a>
                    <ul>
                        <li><a href="#1131-definition-typed-rule-from-a-literal">11.3.1. Definition: Typed Rule from a
                                literal</a></li>
                        <li><a href="#1132-definition-typed-rule-from-components">11.3.2. Definition: Typed Rule from
                                components</a></li>
                        <li><a href="#1133-definition-typed-rule-from-components-using-module-as-name">11.3.3.
                                Definition: Typed Rule from components using Module as Name</a></li>
                        <li><a href="#1134-definition-typed-rule-from-point-tag">11.3.4. Definition: {Typed Rule from
                                Point tag</a></li>
                    </ul>
                </li>
                <li><a href="#114-indifferent-rules">11.4. Indifferent Rules</a>
                    <ul>
                        <li><a href="#1141-definition-indifferent-rules-for-unused-connectors">11.4.1. Definition:
                                Indifferent Rules for unused Connectors</a></li>
                        <li><a href="#1142-definition-indifferent-rules-manual-assignment">11.4.2. Definition:
                                Indifferent Rules manual assignment</a></li>
                        <li><a href="#1143-definition-indifferent-rules-literal-assignment">11.4.3. Definition:
                                Indifferent Rules literal assignment</a></li>
                    </ul>
                </li>
                <li><a href="#115-defining-more-modules-at-once">11.5. Defining more Modules at once</a>
                    <ul>
                        <li><a href="#1151-pseudo-code-almost-without-data-trees">11.5.1. Pseudo code: (almost) without
                                data trees</a></li>
                        <li><a href="#1152-definition-almost-without-data-trees">11.5.2. Definition: (almost) without
                                data trees</a></li>
                        <li><a href="#1153-pseudo-code-with-data-trees">11.5.3. Pseudo code: with data trees</a></li>
                        <li><a href="#1154-definition-with-data-trees">11.5.4. Definition: with data trees</a></li>
                        <li><a href="#1155-result">11.5.5. Result</a></li>
                    </ul>
                </li>
                <li><a href="#116-slots-and-module-parts-with-non-uniforms-dimensions">11.6. Slots and Module Parts with
                        non-uniforms dimensions</a>
                    <ul>
                        <li><a href="#1161-definition">11.6.1. Definition</a></li>
                        <li><a href="#1162-result">11.6.2. Result</a></li>
                    </ul>
                </li>
                <li><a href="#117-modules-and-envelope-with-individual-base-planes">11.7. Modules and Envelope with
                        individual base planes</a></li>
                <li><a href="#118-disallowing-rules">11.8. Disallowing Rules</a>
                    <ul>
                        <li><a href="#1181-definition">11.8.1. Definition</a></li>
                    </ul>
                </li>
                <li><a href="#119-modules-with-more-parts">11.9. Modules with more Parts</a>
                    <ul>
                        <li><a href="#1191-definition-module-part-points-created-manually">11.9.1. Definition: Module
                                Part Points created manually</a></li>
                        <li><a href="#1192-definition-module-part-points-created-manually-from-geometry">11.9.2.
                                Definition: Module Part Points created manually from geometry</a></li>
                        <li><a href="#1193-definition-module-part-points-created-with-slice-geometry">11.9.3.
                                Definition: Module Part Points created with Slice Geometry</a></li>
                    </ul>
                </li>
                <li><a href="#1110-empty-module-and-allowing-an-empty-neighbor">11.10. Empty Module and allowing an
                        Empty neighbor</a>
                    <ul>
                        <li><a href="#11101-definition-empty-module-and-additional-explicit-rules">11.10.1. Definition:
                                Empty Module and additional Explicit Rules</a></li>
                        <li><a href="#11102-definition-explicit-rules-with-all-connectors-of-empty">11.10.2. Definition:
                                Explicit Rules with all Connectors of Empty</a></li>
                        <li><a href="#11103-definition-multiple-different-empty-modules">11.10.3. Definition: Multiple
                                different Empty Modules</a></li>
                    </ul>
                </li>
                <li><a href="#1111-allowing-modules-to-be-at-the-boundary-of-the-envelope">11.11. Allowing Modules to be
                        at the boundary of the Envelope</a>
                    <ul>
                        <li><a href="#11111-definition">11.11.1. Definition</a></li>
                    </ul>
                </li>
                <li><a href="#1112-constructing-slots">11.12. Constructing Slots</a>
                    <ul>
                        <li><a href="#11121-definition-slots-from-manually-generated-points">11.12.1. Definition: Slots
                                from manually generated points</a></li>
                        <li><a href="#11122-definition-slots-from-manually-generated-points-from-geometry">11.12.2.
                                Definition: Slots from manually generated points from geometry</a></li>
                        <li><a href="#11123-definition-slots-from-slice-geometry-points">11.12.3. Definition: Slots from
                                Slice Geometry: Points</a></li>
                        <li><a href="#11124-definition-slots-from-slice-geometry-curves">11.12.4. Definition: Slots from
                                Slice Geometry: Curves</a></li>
                        <li><a href="#11125-definition-slots-from-slice-geometry-surfaces">11.12.5. Definition: Slots
                                from Slice Geometry: Surfaces</a></li>
                        <li><a href="#11126-definition-slots-from-slice-geometry-mesh-and-brep-volumes">11.12.6.
                                Definition: Slots from Slice Geometry: Mesh and Brep volumes</a></li>
                        <li><a href="#11127-definition-slots-from-slice-geometry-miscellaneous-geometry">11.12.7.
                                Definition: Slots from Slice Geometry: Miscellaneous geometry</a></li>
                    </ul>
                </li>
                <li><a href="#1113-preventing-duplicate-slots-from-points">11.13. Preventing duplicate Slots from
                        points</a>
                    <ul>
                        <li><a href="#11131-definition">11.13.1. Definition</a></li>
                    </ul>
                </li>
                <li><a href="#1114-allowing-certain-modules-in-certain-slots">11.14. Allowing certain Modules in certain
                        Slots</a>
                    <ul>
                        <li><a href="#11141-definition-allowing-modules-modules-in-certain-area">11.14.1. Definition:
                                Allowing Modules modules in certain area</a></li>
                        <li><a href="#11142-definition-disallowing-modules-modules-in-certain-area">11.14.2. Definition:
                                Disallowing Modules modules in certain area</a></li>
                        <li><a href="#11143-definition-allowing-modules-modules-based-on-attractor">11.14.3. Definition:
                                Allowing Modules modules based on attractor</a></li>
                        <li><a href="#11144-roulette-approach-to-weighted-probability">11.14.4. Roulette approach to
                                weighted probability</a></li>
                        <li><a href="#11145-definition-roulette---choosing-a-binary-weighted-option">11.14.5.
                                Definition: Roulette - Choosing a binary weighted option</a></li>
                        <li><a href="#11146-definition-roulette---choosing-one-weighted-option-from-multiple-choices">11.14.6.
                                Definition: Roulette - Choosing one weighted option from multiple choices</a></li>
                        <li><a href="#11147-definition-roulette---choosing-more-weighted-options-from-multiple-choices">11.14.7.
                                Definition: Roulette - Choosing more weighted options from multiple choices</a></li>
                        <li><a href="#11148-definition-allowing-modules-based-on-vertical-gradient">11.14.8. Definition:
                                Allowing Modules based on vertical gradient</a></li>
                        <li><a href="#11149-definition-allowing-modules-based-on-multiple-attractor-gradients">11.14.9.
                                Definition: Allowing Modules based on multiple attractor gradients</a></li>
                    </ul>
                </li>
                <li><a href="#1115-fixing-modules-in-envelope-before-running-the-solver">11.15. Fixing Modules in
                        Envelope before running the Solver</a></li>
                <li><a href="#1116-disallowing-certain-modules-from-certain-slots">11.16. Disallowing certain Modules
                        from certain Slots</a>
                    <ul>
                        <li><a href="#11161-definition-disallowing-modules-in-new-slots">11.16.1. Definition:
                                Disallowing Modules in new Slots</a></li>
                        <li><a href="#11162-definition-disallowing-modules-in-existing-slots">11.16.2. Definition:
                                Disallowing Modules in existing Slots</a></li>
                    </ul>
                </li>
                <li><a href="#1117-enforcing-specific-modules-at-the-boundary-of-the-envelope">11.17. Enforcing specific
                        modules at the boundary of the Envelope</a>
                    <ul>
                        <li><a href="#11171-definition">11.17.1. Definition</a></li>
                        <li><a href="#11172-definition-identifying-more-boundary-layers">11.17.2. Definition:
                                Identifying more boundary layers</a></li>
                    </ul>
                </li>
                <li><a href="#1118-growing-the-boundary-of-the-envelope">11.18. Growing the boundary of the Envelope</a>
                    <ul>
                        <li><a href="#11181-definition">11.18.1. Definition</a></li>
                    </ul>
                </li>
                <li><a href="#1119-materializing-results">11.19. Materializing results</a>
                    <ul>
                        <li><a href="#11191-definition">11.19.1. Definition</a></li>
                    </ul>
                </li>
                <li><a href="#1120-proto-results-and-custom-materialization">11.20. Proto-results and custom
                        materialization</a>
                    <ul>
                        <li><a href="#11201-definition">11.20.1. Definition</a></li>
                    </ul>
                </li>
                <li><a href="#1121-using-the-transform-data-to-materialize-the-result">11.21. Using the transform data
                        to materialize the result</a>
                    <ul>
                        <li><a href="#11211-definition">11.21.1. Definition</a></li>
                    </ul>
                </li>
                <li><a href="#1122-random-seed-and-attempts-count">11.22. Random seed and attempts count</a></li>
                <li><a href="#1123-visualizing-rules">11.23. Visualizing Rules</a>
                    <ul>
                        <li><a href="#11231-definition">11.23.1. Definition</a></li>
                    </ul>
                </li>
                <li><a href="#1124-visualizing-allowed-module-couples">11.24. Visualizing allowed Module couples</a>
                    <ul>
                        <li><a href="#11241-definition-visualizing-one-module-couple">11.24.1. Definition: Visualizing
                                one Module couple</a></li>
                        <li><a href="#11242-definition-visualizing-a-catalog-of-module-couples">11.24.2. Definition:
                                Visualizing a catalog of Module couples</a></li>
                    </ul>
                </li>
            </ul>
        </li>
        <li><a href="#12-faq">12. FAQ</a>
            <ul>
                <li><a href="#121-what-is-a-good-exercise-to-start-using-monoceros">12.1. What is a good exercise to
                        start using Monoceros?</a></li>
                <li><a href="#122-what-does-the-error-world-state-is-contradictory-mean">12.2. What does the error
                        &quot;World state is contradictory&quot; mean?</a></li>
                <li><a href="#123-why-the-solver-cannot-find-any-solution-even-after-1000-attempts">12.3. Why the Solver
                        cannot find any solution even after 1000 attempts?</a></li>
                <li><a href="#124-what-makes-a-good-module">12.4. What makes a good Module?</a></li>
                <li><a href="#125-what-makes-a-good-envelope">12.5. What makes a good Envelope?</a></li>
                <li><a href="#126-why-does-the-slice-geometry-component-give-invalid-results">12.6. Why does the Slice
                        Geometry component give invalid results?</a></li>
                <li><a href="#127-how-to-set-a-rule-for-a-module-distant-two-or-more-slots">12.7. How to set a Rule for
                        a Module distant two or more Slots?</a></li>
                <li><a href="#128-are-block-instances-or-groups-supported-by-monoceros">12.8. Are block instances or
                        groups supported by Monoceros?</a></li>
            </ul>
        </li>
        <li><a href="#13-partners">13. Partners</a></li>
        <li><a href="#14-mit-license">14. MIT License</a></li>
    </ul>
    <h2 id="4-meet-monoceros">4. Meet Monoceros</h2>
    <p><img src="./readme-assets/monoceros512.png" alt="Monoceros"></p>
    <blockquote>
        <p>Monoceros is a legendary animal living in the huge mountains in the interior of India. Monoceros has the body of a horse, the head of a stag, the feet of an elephant and the tail of a boar.
            <a href="https://karkadann.fandom.com/wiki/Monoceros">from Unicorn Wiki</a>
        </p>
    </blockquote>
    <p>It is also a plug-in for <a href="https://www.grasshopper3d.com">Grasshopper</a>, which is a visual programming platform for <a href="https://www.rhino3d.com">Rhinoceros</a> 3D CAD software. Monoceros was developed at studio
        <a href="https://www.sub.digital">Subdigital</a> by Ján Toth and Ján Pernecký. Monoceros is an implementation of the Wave Function Collapse (WFC) algorithm developed for game design by <a href="https://github.com/mxgmn/WaveFunctionCollapse">Maxim Gumin</a>        and extended and promoted by <a href="https://oskarstalberg.com">Oskar Stålberg</a> with his game <a href="https://store.steampowered.com/app/1291340/Townscaper/">Townscaper</a>.
    </p>
    <p><img src="./readme-assets/grasshopper-panel.png" alt="grasshopper panel"></p>
    <p>Monoceros serves to fill the entire world with Modules, respecting the given Rules. The plug-in wraps WFC into a layer of abstraction, which makes WFC easily implemented in architectural or industrial design. It honors the principles of WFC and Grasshopper
        at the same time - offering a full control of the input and output data in a Grasshopper way and their processing with a pure WFC.</p>
    <h2 id="5-wave-function-collapse">5. Wave Function Collapse</h2>
    <p>Before we delve deeper, let's shortly explain the WFC algorithm itself. Note that Monoceros extends some concepts over the vanilla WFC, but it is very helpful to understand the original version of the algorithm first. To that end, it might also be
        helpful to watch the excellent <a href="https://www.youtube.com/watch?v=0bcZb-SsnrA">explanatory talk by Oskar
            Stålberg at EPC2018</a>.</p>
    <p>Wave Function Collapse (WFC) is a procedural generation algorithm that essentially attempts to satisfy constraints on a world (see
        <a href="https://en.wikipedia.org/wiki/Constraint_satisfaction_problem">CSP</a> for more). Its name is inspired by quantum mechanics, but the similarity is just at the surface level - WFC runs completely deterministically.
    </p>
    <p>In its simplest form the algorithm works on an orthogonal grid. We initially have:
    </p>
    <ul>
        <li>
            <p>A world defined by a <a href="https://en.wikipedia.org/wiki/Graph_(discrete_mathematics)">mathematical
                    graph</a>, in our case represented as an orthogonal 3D grid.</p>
        </li>
        <li>
            <p>A set of Rules describing what can occupy each tile on the grid depending on what its neighbors are.</p>
        </li>
    </ul>
    <p>The grid tiles are graph nodes, also called Slots in WFC (and in Monoceros). Graph edges are implicitly derived from Slot adjacency: two Slots are connected by an edge, if they are adjacent to each other on the grid. Every Slot contains a list of
        Modules that are allowed to reside in it. Conceptually, Modules could have any meaning that we assign to them, some usual meanings being that the Slots populated by them contain geometry, images, navigation meshes, or other high-level descriptions
        of a space.</p>
    <p>The algorithm is defined as follows:</p>
    <ol>
        <li>
            <p>Initialize the world to a fully non-deterministic state, where every Slot allows every defined Module.
            </p>
        </li>
        <li>
            <p>Repeat following steps until every Slot allows exactly one Module (a valid, deterministic result), or any Slot allows zero Modules (a contradiction):</p>
            <ol>
                <li>
                    <p><strong>Observation (Slot choice):</strong> Pick a Slot at random from the set of Slots with the smallest Module count that are still in non-deterministic state (allow more than one Module),
                    </p>
                </li>
                <li>
                    <p><strong>Observation (Module choice):</strong> Randomly pick a Module from the set of still available Modules for the chosen Slot and remove all other Modules from this Slot, making it deterministic (allowing exactly one Module),</p>
                </li>
                <li>
                    <p><strong>Constraint Propagation:</strong> Remove Modules from neighboring Slots based on the Rules. Repeat recursively in <a href="https://en.wikipedia.org/wiki/Depth-first_search">depth-first
                            order</a> for each Slot modified this way.</p>
                </li>
            </ol>
        </li>
        <li>
            <p>If WFC generated a contradictory result, start over again with a different random state.</p>
        </li>
    </ol>
    <p><strong>WFC does not necessarily always find a solution</strong>. If (and how quickly) a valid solution is computed very much depends on the set of provided Rules. There are sets of Rules for which WFC always converges in just a single attempt regardless
        of the random state, but also sets of Rules for which the simulation always results in a contradictory world state, and also everything in between. Rule design is a challenging part of working with Wave Function Collapse.
    </p>
    <h2 id="6-development-notes">6. Development notes</h2>
    <p>This repository contains the Grasshopper wrapper for the main WFC solver and comprehensive supplemental tools.
    </p>
    <p><em>The solver itself is written in Rust and compiled as a <code>.dll</code> library linked to
            this wrapper. The source code of the solver and a simple wrapper component for
            Grasshopper lives in a separate <a href="https://github.com/subdgtl/WFC">repository</a>.</em></p>
    <p>The Monoceros Grasshopper plug-in is written in C## and revolves around three main data types:</p>
    <ol>
        <li><strong>Slot</strong> is the basic cuboid unit of a discrete world. The Slots can be embedded with Modules or their Parts. Initially the Slots allow containment of multiple Modules until the WFC solver reduces the list of allowed Modules to a
            single Module for each Slot according to given Rules.</li>
        <li><strong>Module</strong> represents geometry wrapped into one or more cuboid cages (similar to the Slots). Modules are about to be placed into the Slots according the given Rules.</li>
        <li><strong>Rule</strong> describes allowed adjacency of two Modules or their Parts via one of the walls of the cuboid cages - connectors.</li>
    </ol>
    <p>The Monoceros plug-in offers various Grasshopper <strong>components</strong> (functions) for constructing and parsing the data, the solver itself and postprocessing and rendering tools.</p>
    <h2 id="7-architecture-of-monoceros-grasshopper-plug-in">7. Architecture of Monoceros Grasshopper plug-in</h2>
    <p>The core of Monoceros is a Wave Function Collapse (WFC) solver. WFC is an algorithm that fills the entire discrete envelope with Modules with no remaining empty Slot. In case of Monoceros, the envelope is a collection of rectangular cuboid Slots,
        each with 6 neighbors in orthogonal directions, not taking diagonal neighbors into account. In the original WFC algorithm, the Modules are exactly the size of a single Slot. WFC then picks which Module should be placed into which Slot, leaving
        no Slot non-deterministic (with more than one Module allowed to be placed into the Slot) or empty / contradictory (no Module allowed to be placed into the Slot). Usually, there are less Modules (Module types) than Slots, which means each Module
        can be placed into Slots more times or not at all.
    </p>
    <p>The Monoceros implementation of WFC internally works like this too, on the outside it presents the Modules as a continuous coherent compact collection of such cuboid cages (Module Parts), each fitting into one Slot.</p>
    <p>Like Grasshopper itself, also Monoceros revolves around data and serves for its immutable processing. Immutability means, that no existing data is being changed but rather transformed and returned as a new instance of the data. In most cases it is
        even possible to construct the data with valid values right away with no need to re-define already existing data.
    </p>
    <p>There are three main data types: <strong>Slot</strong>s, <strong>Module</strong>s and <strong>Rule</strong>s.</p>
    <p>Slot and Rule both reference to Module, its Part or its Connector. This reference is done only through user defined strings (for Modules and their Parts) or integer indices (for Module Connectors). This is an intention, so that the data sets (Modules,
        Rules or Slots) can be replaced or shared across more Monoceros setups.</p>
    <table>
        <thead>
            <tr>
                <th style="text-align:right">Construct</th>
                <th style="text-align:center"></th>
                <th style="text-align:center">Solve</th>
                <th style="text-align:center"></th>
                <th style="text-align:left">Post process</th>
            </tr>
        </thead>
        <tbody>
            <tr>
                <td style="text-align:right"><strong>Modules</strong></td>
                <td style="text-align:center"><strong>-&gt;</strong></td>
                <td style="text-align:center"></td>
                <td style="text-align:center"></td>
                <td style="text-align:left"></td>
            </tr>
            <tr>
                <td style="text-align:right"><strong>Rules</strong></td>
                <td style="text-align:center"><strong>-&gt;</strong></td>
                <td style="text-align:center"><strong>WFC Solver</strong></td>
                <td style="text-align:center"><strong>-&gt;</strong></td>
                <td style="text-align:left"><strong>Materialize</strong></td>
            </tr>
            <tr>
                <td style="text-align:right"><strong>Slots</strong></td>
                <td style="text-align:center"><strong>-&gt;</strong></td>
                <td style="text-align:center"></td>
                <td style="text-align:center"></td>
                <td style="text-align:left"></td>
            </tr>
            <tr>
                <td style="text-align:right"></td>
                <td style="text-align:center"></td>
                <td style="text-align:center">Aggregate</td>
                <td style="text-align:center"></td>
                <td style="text-align:left"></td>
            </tr>
            <tr>
                <td style="text-align:right"></td>
                <td style="text-align:center"></td>
                <td style="text-align:center">Preview</td>
                <td style="text-align:center"></td>
                <td style="text-align:left"></td>
            </tr>
        </tbody>
    </table>
    <p>Most of the Monoceros plug-in components serve for constructing, analyzing and processing data. The components try not to bring redundancy, therefore it does not do anything, that could be easily done with vanilla Grasshopper components. The three
        new Monoceros data types are seamlessly integrated into Grasshopper and cast from and to all relevant existing data types. All Monoceros components are compatible with the existing Grasshopper data types and ready to be used with existing Grasshopper
        components.
    </p>
    <h2 id="8-data-types">8. Data types</h2>
    <h3 id="81-slot">8.1. Slot</h3>
    <p>Slot is a cuboid (orthogonal box) that represents the basic unit of the Monoceros rigid discrete grid. The Slots do not overlap and their position coordinates are defined in discrete numerical steps. The Slots are stacked next to each other, preferably
        forming a coherent continuous blob or more separate blobs that should become filled with Modules. Such blob will be called an Envelope.
    </p>
    <h4 id="811-states">8.1.1. States</h4>
    <p>Slot is a container that allows placement of certain Modules or their Parts. The Slot can be in several states:
    </p>
    <ol>
        <li><strong>Allows Nothing</strong> is a contradictory (invalid) state, when there is no Module or its Part that can be placed inside the Slot. If the collection of Slots forming the Envelope of the solution contains one or more such Slots, the solution
            cannot be found and therefore such setup is invalid.</li>
        <li><strong>Allows one Module</strong> (or deterministic state) is the desired state of a Slot. It is the responsibility of the WFC Solver to bring a non-deterministic Slot into a deterministic state. Such Slot can be Materialized - a Module can be
            placed into the Slot.</li>
        <li><strong>Allows more Modules</strong> (or non-deterministic state) is usually an initial or intermediate state of a Slot, when it is not yet clear, which Module or its Part should be placed inside the Slot, but a list of allowed Modules is present.
            It is the responsibility of the WFC Solver to bring a non-deterministic Slot into a deterministic state. A non-deterministic Slot cannot be Materialized yet but it is possible to evaluate its level of entropy - a number of currently allowed
            Modules or their Parts stating how far from the deterministic state the Slot is.</li>
        <li><strong>Allows all Modules</strong> is a shortcut for a fully non-deterministic state, when any Module or its Part is allowed to be placed inside the Slot. In practice this state exists only for cases, when Slots are being defined before or independently
            from Modules and therefore it is not possible to list Modules that should be allowed by the Slot.</li>
    </ol>
    <p>The collection of Slots forming an Envelope is considered Canonical if the adjacent Slots allow placement of such Modules or their Parts, that are allowed to be neighbors by the Rules. Canonical Envelope does not have to be also deterministic. For
        non-deterministic Slots to form a Canonical Envelope, each allowed Module or its Part in one Slot must be allowed to be a neighbor of each allowed Module or its Part in its adjacent Slot in the given direction by the Rule set.</p>
    <p>The Monoceros implementation of the WFC algorithm can automatically clean a Non-Canonical Envelope into Canonical, which takes a lot of responsibility from the user and enables future development of Monoceros features.
    </p>
    <h4 id="812-slot-properties">8.1.2. Slot Properties</h4>
    <ul>
        <li><strong>Center</strong> of the Slot in cartesian coordinate system. The coordinate is automatically rounded so that it represents an exact center of the Slot in the discrete world coordinate system.</li>
        <li><strong>Base Plane</strong> defining Slot's coordinate system. The discrete world coordinate system's origin and axial orientation matches that of the Base Plane. For two Slots to be compatible, their Base Planes must match.
        </li>
        <li><strong>Diagonal</strong> defining Slot's dimensions in X, Y and Z directions as defined by the Base Plane. For two Slots to be compatible, their Diagonals must match.</li>
        <li><strong>Allowed Module Names</strong> is a list of Modules that are allowed to be placed (entire Modules or their Parts) inside the Slot. This list is empty, when the Slot is in the Allows Nothing or Allows Everything state.</li>
        <li><strong>Allows Everything</strong> is a flag determining whether the Slot allows placement of any Module or its Part.</li>
        <li><strong>Allows Nothing</strong> is a flag determining whether the Slot allows placement of no Module or its Part. Such Slot is invalid and prevents the WFC Solver from reducing other Slots from non-deterministic to deterministic state.</li>
    </ul>
    <h4 id="813-automatic-envelope-wrapping">8.1.3. Automatic Envelope wrapping</h4>
    <p>The WFC algorithm (the original one and the Monoceros implementation) work with a full regular three-dimensional box-like Envelope. Monoceros allows the user to define any set of Slots (as long as they are compatible and non-repetitive), which form
        any arbitrary blob.</p>
    <p>Therefore the Monoceros WFC Solver component automatically wraps the user-defined Slots into a slightly larger bounding box and adds the missing Slots. These Slots are dubbed Out-enabled and are pre-determined to allow only one type of a Module to
        be placed inside them: the Out Module. Out Module is automatically generated by the Monoceros WFC Solver, it has the same diagonal as the Envelope Slots, has just a single Part and contains no geometry. The Out Module has all connectors defined
        as Indifferent, therefore it is allowed to be adjacent to itself and with any other Module Indifferent in the respective direction. The Out Module and an Empty Module are distinguished so that it is possible to set a Rule for a Module Connector
        to be adjacent to Out Module (while not being Indifferent), which allows the Module to be placed at the boundary of the Envelope.</p>
    <p>All boundary Slots are ensured to be surrounded by Out-enabled Slots. The Out-enabled Slots are not being displayed in the Rhinoceros viewport.</p>
    <h4 id="814-modules-and-their-parts">8.1.4. Modules and their Parts</h4>
    <p>The Monoceros Modules may consist of more Parts. Each Part is of the size of a single Slot, therefore a larger Module occupies more Slots. For valid Modules it is ensured that the Module Parts always hold together and all of the Module Parts are always
        placed into Slots in the original order. Internally, the Slots refer to Module Parts, for the user of Monoceros Grasshopper plug-in are the Module Parts inaccessible and the Module appears as the smallest unbreakable unit. Therefore it is only
        possible to define entire Modules to be allowed by a Slot, even when such Module consists of more Parts. Internally this means, that all Parts of the Module are allowed to be placed into a Slot. In practice this should not cause any problems or
        imprecisions. It is being automatically handled by the WFC Solver and offers some buffer zone for complex Module placement.
    </p>
    <h4 id="815-viewport-preview-and-baking">8.1.5. Viewport preview and baking</h4>
    <p>A Slot renders in the viewport as a wire frame box. The box is slightly smaller than the actual Slot, so that it is possible to distinguish colors of two adjacent Slots from one another.</p>
    <p>A Slot bakes as a regular Rhino box, with dimensions matching the Slot size.</p>
    <p>A Slot renders and bakes in different colors, indicating the level of Slot's entropy:
    </p>
    <ul>
        <li><strong>Red</strong> - the Slot does not allow placement of any Module or its Part, therefore is empty and invalid.
        </li>
        <li><strong>White</strong> - the Slot allows placement of any Module or its Part that enters the Monoceros WFC Solver.
        </li>
        <li><strong>Blue</strong> - the Slot allows placement of more than one Module or its Part but the overall number of Modules is unknown to the Slot. This is a valid state for Slots defined by enumerating the allowed Modules. A Slot is blue even when
            all Modules are allowed, but they have been listed namely instead of using the Allow all constructor.</li>
        <li><strong>Green</strong> - the Slot allows placement of exactly one Module Part and is ready to be Materialized. This is currently only possible for Slots processed by the Monoceros WFC Solver. Green color denotes the desired state of a Slot.</li>
        <li><strong>Grey</strong> - the Slot allows placement of some Modules or their Parts and the overall number of Modules and their Parts is known. Bright color indicates a high level of entropy - more Modules or their Parts are (still) allowed to be
            placed into the Slot. Dark grey means the Slot has a lower entropy and is closer to a solution.</li>
    </ul>
    <h4 id="816-slot-casts-to">8.1.6. Slot casts to</h4>
    <p>The Casts are meant to shorten the de-construction and re-construction of a Slot. With the following casts it is possible to use one instance of a Slot to construct a new one with the same properties by passing the Slot into individual input Slots
        of a Slot constructor component.</p>
    <ul>
        <li><strong>Point</strong> - representing the center point of the Slot</li>
        <li><strong>Box</strong> and <strong>BRep</strong> - representing the exact box cage of the Slot</li>
        <li><strong>Vector</strong> - representing the Diagonal of the Slot</li>
        <li><strong>Text</strong> (string) - returns a human-friendly report of the Slot's properties in format:
            <code>Slot allows placement of XY Modules. Slot dimensions are XYZ, center is at XYZ, Base Plane is XYZ X Y.</code>
        </li>
    </ul>
    <h3 id="82-module">8.2. Module</h3>
    <p>Module is a unit, which is being distributed over the specified Envelope. The main purpose of the WFC and Monoceros is to decide, which Module or its Part can be placed into which Slot, so that the adjacencies of Modules follows the specified Rule
        set. If this requirement is met, it means the Envelope is Canonical. If there is exactly one Module or its Part allowed to be placed into every Slot, the Envelope is Deterministic and solved.</p>
    <h4 id="821-monoceros-module-parts">8.2.1. Monoceros Module Parts</h4>
    <p>offers a possibility for Modules to span over (occupy) more Slots. In such case, In the original WFC algorithm, the Module occupies exactly one Slot. Monoceros the Module consists of more Parts, each of a size of a single Slot. If the Module is compact
        (continuous, consistent) then the Parts always hold together (this is secured by the Monoceros WFC Solver). The Module Parts are not accessible individually, the Module is rather presented as a single element.</p>
    <p>A Module can consist of a single Part or more Parts. The Parts that are entirely surrounded by other Parts in all 6 orthogonal directions, are not being presented to the user at all. Only the boundary walls of Module Parts are visible and form an
        orthogonal discrete unit cage of a Module.</p>
    <h4 id="822-connectors">8.2.2. Connectors</h4>
    <p>The Module cages are subdivided to match the size of Envelope Slots in their respective directions. The outer walls of a Module cage are considered to be Connectors. Connectors are numbered from <code>0</code> to
        <code>n-1</code>, where <code>n</code> stands for the number of (outer) Connectors of the respective Module.</p>
    <p>The Monoceros Modules are designed to connect to each other through their Connectors. To enable such connection it must be described by a Monoceros Rule. A Connector can occur in multiple Rules, allowing it to connect to multiple counter-Connectors,
        out of which one will be chosen by the WFC Solver. Each Connector must occur in at least one Monoceros Rule, otherwise the Connector cannot have any neighbor, therefore such Module cannot be placed into the Solution.
    </p>
    <p>Monoceros Rules may allow connection of Connectors from the same Module or from two distinct Modules. A Rule, therefore also a connection, is only valid when the two Connectors are in opposite orientation of the same axis (i.e. negative Y can connect
        only to positive Y).</p>
    <p>Monoceros Rules are referring to Module names and Connector Indices. The supplemental Monoceros components for constructing Rules use visual representation of Connectors (rectangles or dots) to identify the Rule being created.
    </p>
    <h4 id="823-module-geometry">8.2.3. Module Geometry</h4>
    <p>The purpose of a Monoceros Module is to place geometry into dedicated Slots. The Module data type is not bound to its geometry, which means the shape, size and location of Module geometry has no relation to the Parts of the Module or Slots it may
        occupy. This is an intentional feature because in real-life architectural and design applications, the Modules will need to posses extending parts (physical connectors) that would not fit the cages of Module Parts and therefore would compromise
        the WFC solution.</p>
    <p>Therefore, the Module Geometry may be small, larger, different than the Module cage or remain completely empty.
    </p>
    <p>Therefore a Module is being constructed from different input data than its Geometry. To mark Module Parts (Slots the Module may occupy) the user specifies Points inside these Parts. For convenience, it is possible to use Slicer helper component, that
        analyzes input geometry (no matter whether it is the same geometry that is being held by the Module or a different one) and returns exact centers of Slots that may be occupied by Module Parts.</p>
    <h4 id="824-orientation-and-placement">8.2.4. Orientation and placement</h4>
    <p>A Module has a fixed orientation. When it is being placed into Slots it is only being translated (moved) and never rotated. There are maximum of 24 different discreet 90 degree rotations of an object. Rotating all Modules automatically would take
        a lot of control from the user. Therefore, if any rotation is desired, it has to be done manually by creating a new, different rotated version of the Module. The best way to do this it to rotate and adjust all input data (Module Part Points, Module
        Geometry) and give it a different name.</p>
    <h4 id="825-module-properties">8.2.5. Module Properties</h4>
    <ul>
        <li><strong>Name</strong> - is a string unique identifier assigned by the user. The Name is automatically converted to lowercase. All Monoceros components with Module list input check if the Module names are unique. If not, they do not compute. The
            name is the sole identifier of a Module for all purposes, so that it is possible to replace a set of Modules within a solution with a different one.</li>
        <li><strong>Module Part Center Points</strong> - center Points of Module Parts in cartesian coordinate system. The points are automatically calculated and can be used to create a new Module with the same Parts (cage) or to define the Slot Envelope
            exactly around the Module.</li>
        <li><strong>Geometry</strong> - geometry to be placed into Slots with Materialize component.</li>
        <li><strong>Base Plane</strong> defining Module's coordinate system. The discrete world coordinate system's origin and axial orientation matches that of the Base Plane. For a Module to be compatible with Slots, their Base Planes must match.</li>
        <li><strong>Module Part Diagonal</strong> - defining Module Part's dimensions in X, Y and Z directions as defined by the Base Plane. For a Module to be compatible with Slots, their Diagonals must match.</li>
        <li><strong>Connectors</strong> - reveals the Module Connectors as Planes tangent to the Connector rectangle, with Normal pointing outwards and origin at the Connector center. The Connector Indices (or their order in this list) does not represent
            their direction.</li>
        <li><strong>Connector Directions</strong> - unit vectors aligned to the base plane indicating the direction of connector's normal (i.e. positive X direction is always {1, 0, 0}, negative Z is always {0, 0, -1}). Returns a list parallel to the list
            of Connectors.</li>
        <li><strong>Connector Use Pattern</strong> - is a boolean list computed from the Module and the list all Rules indicating whether the Connectors have been already described by any Rule. The Monoceros WFC Solver requires each Module Connector to be
            described by at least one Rule, therefore it is important to generate some Rules for all unused Connectors before attempting to find a solution. Returns a list parallel to the list of Connectors.</li>
        <li><strong>Is Compact</strong> - single boolean value indicating whether the Module Parts create a coherent compact continuous blob. If there are any gaps or Parts touching only with edges or corners, the Module is not compact. Such Module would
            not hold together in the WFC solution and therefore is automatically skipped by the Monoceros WFC Solver. It is allowed to construct such Module and to preview it in the viewport, so that the user can manually adjust the input parameters and
            construct a compact Module.</li>
        <li><strong>Is Valid</strong> - internally, there are many reasons why a Module could be invalid, but only one reason is allowed to happen in Grasshopper: if a Module consists of too many Parts. The current upper limit is 256 Parts for all Modules
            combined. If a single Module outreaches this value, it is marked as invalid. It is allowed to construct such Module and to preview it in the viewport, so that the user can manually adjust the input parameters and construct a valid Module.</li>
    </ul>
    <h4 id="826-special-modules-out-and-empty">8.2.6. Special Modules: Out and Empty</h4>
    <p>There are two reserved Module names in Monoceros: <strong>Out</strong> and <strong>Empty</strong>. It is not allowed to manually construct a Module with such name, because they are being constructed automatically.</p>
    <p>The Out Module is present in each solution. It is a Module with a single Part, exactly the size of a single Slot and holds no Geometry. It is automatically placed into Slots outside the user-defined Envelope. All Out Module Connectors are marked with
        Indifferent Rules, so any Module with an Indifferent Rule marked Connectors can be placed next to it - in other words, it enables the Indifferent Modules to be on the boundary of the Envelope. The Out Module does not render in preview, nor bakes.</p>
    <p>The Empty Module with a single Part, exactly the size of a single Slot, no Geometry and all Connectors marked with Indifferent Rules has to be constructed manually with a dedicated Monoceros component. It behaves as any other Module because it is
        a regular Module that can be constructed also without the special Monoceros component. It render in viewport, it can be baked, so that individual Rules can be assigned to it. The Empty Module helps complex Monoceros setups to find a solution,
        because it fills the gaps between complex Modules and their Parts.
    </p>
    <h4 id="827-viewport-preview-and-baking">8.2.7. Viewport preview and baking</h4>
    <p>Module preview renders in Rhinoceros viewport with many helper items:</p>
    <ul>
        <li><strong>Cage</strong> - boundary Connectors of Module Parts render and bake as wire frame rectangles. The Cage is white when the Module is valid, red when it is invalid because it is no compact or consists of too many Parts.</li>
        <li><strong>Name</strong> - renders as a large text, green if the Module is valid, red it is invalid. The Module Name bakes as a text dot with the Name as a label.</li>
        <li><strong>Connectors</strong> - render and bake as text dots with Connector Index as a label. The dots are placed in the center of the Connector rectangle. The dots render in colors indicating their direction:
            <ul>
                <li>Red = X</li>
                <li>Green = Y</li>
                <li>Blue = Z</li>
                <li>White text = positive orientation</li>
                <li>Black text = negative orientation</li>
            </ul>
        </li>
        <li><strong>Geometry</strong> - renders as regular Grasshopper geometry but does not bake</li>
    </ul>
    <p>The helper geometry preview does not follow the Grasshopper convention of a transparent green material for selected items and red for unselected.</p>
    <p>The purpose of Module baking is to provide helper geometry and anchors for defining Monoceros Rules. It is possible to snap to Connectors or Cages to define a Rule graphically.</p>
    <h4 id="828-module-casts">8.2.8. Module casts</h4>
    <p>Module casts help using the Module directly as an input to various components, even when they require a Module name, i.e. Rule or Slot Constructors.</p>
    <ul>
        <li><strong>Module Name</strong> - is a special Monoceros data type that wraps a string name of a Module. Direct cast to a string is already taken by the user-friendly report, therefore the Module first casts its name to Module Name type, which then
            casts into text (string) for user-friendly report. Monoceros components, however, expect the Module Name type. This way it is possible to use the Module as an input where a Module Name is expected and there is no need to deconstruct the Module
            to its properties.</li>
        <li><strong>Text</strong> (string) - returns a human-friendly report of the Module's properties in format:
            <code>Module &quot;XY&quot; has XY connectors and has XY parts with dimensions XYZ.</code> and either
            <code>The Module is compact.</code> or
            <code>WARNING: The Module is not compact, contains islands and therefore will not hold together.</code>
        </li>
    </ul>
    <h3 id="83-rule">8.3. Rule</h3>
    <p>Monoceros Rule is a distinct data type describing an allowed adjacency of two Modules by aligning their Connectors facing opposite direction. The Monoceros WFC Solver parses the Slots so that they only allow placement of Modules or their Parts that
        can become adjacent neighbors according to the Rule set.</p>
    <p>Internally, the WFC Solver only works with Explicit Rules, but for convenience Monoceros offers also a Typed Rule. A Typed Rule is automatically unwrapped into one or more Explicit Rules by the WFC Solver and other supplemental components. Both types
        of Rules manifest as a single data type, can be processed together.</p>
    <p>The Rule refers to Modules via their string (text) names and to Connectors via their integer indices. This allows the same Rule set to be used with a different (yet fully compatible) set of Modules.</p>
    <p>A single Module Connector can be referred to by multiple Rules but at least one referring Rule is required.</p>
    <p>In some cases the Modules cannot connect even though a Rule allows it because their Parts collide. Monoceros does not for check such cases because the WFC Solver itself prevents such situations from happening. That means that even though a Rule is
        valid, it may never occur in the solution.</p>
    <h4 id="831-explicit-rule">8.3.1. Explicit Rule</h4>
    <p>Explicit Rule is closest to the original WFC Rule. It refers to a Connector of one Module that can connector to a Connector of another Module. Its textual representation follows a pattern
        <code>module:connector -&gt; module:connector</code>, i.e.
        <code>pipe:1 -&gt; bulb:4</code>, which translates to: <em>Module &quot;pipe&quot; can become a neighbor of
            Module &quot;bulb&quot; if their connectors 1 and 4 touch</em>.
    </p>
    <p>An Explicit Rule should only allow connection of two non-opposing Connectors, which makes the Rule invalid. Because Connector indices do not indicate their direction, it is only possible to check this when the respective Modules are provided. Therefore
        a full validity check is performed only when both data is available, most importantly in the Monoceros WFC Solver. When the Explicit Rule is created, it is only checked whether it refers to two different Connectors.</p>
    <p>Explicit Rule is bi-directional, therefore <code>a:1 -&gt; b:4</code> equals <code>b:4 -&gt; a:1</code>.</p>
    <h5 id="8311-explicit-rule-properties">8.3.1.1. Explicit Rule properties</h5>
    <ul>
        <li><strong>Source Module Name</strong> - is the unique text identifier of the source Module</li>
        <li><strong>Source Connector Index</strong> - is the unique integer identifier of the source Connector of the source Module</li>
        <li><strong>Target Module Name</strong> - is the unique text identifier of the target Module</li>
        <li><strong>Target Connector Index</strong> - is the unique integer identifier of the target Connector of the target Module</li>
    </ul>
    <h5 id="8312-explicit-rule-casts">8.3.1.2. Explicit Rule casts</h5>
    <p>An Explicit Rule can be cast from a text (string) that has format identical to the user-friendly Explicit Rule text report:
        <code>module:connector -&gt; module:connector</code>. An Explicit Rule does not casts to any other data type.
    </p>
    <h5 id="8313-explicit-rule-viewport-preview-and-baking">8.3.1.3. Explicit Rule Viewport preview and baking</h5>
    <p>An Explicit Rule cannot be displayed on its own. Following a precedent of Vector display component in Grasshopper, there is a <a href="#1053-rule-preview">Rule Preview</a> component in Monoceros. When provided with all Modules, it displays an Explicit
        Rule as a line between the connectors described by the Rule. The color of the line indicates the direction of the connectors (and therefore also of the Rule): red means the connectors are facing X direction, green represents Y direction and blue
        indicates Z direction.</p>
    <p>An Explicit Rule preview can be baked.</p>
    <h4 id="832-typed-rule">8.3.2. Typed Rule</h4>
    <p>Typed Rule is a convenience data type introduced by Monoceros. It assigns a &quot;connection type&quot; to a Connector of one Module, which then can connect to any opposite Connector of any Module with the same &quot;connection type&quot; assigned
        by another Typed Rule. Its textual representation follows a pattern
        <code>module:connector = type</code>, i.e. <code>player:1 = jack</code>, which translates to ` <em>Module
            &quot;player&quot; can become a neighbor of any Module if its connector 1 touches the
            other Module's opposing connector if both connectors are assigned type &quot;jack&quot;</em>.
    </p>
    <p>A Typed Rule needs to be unwrapped into one or more Explicit Rules before entering the WFC Solver. This is done automatically by the Monoceros WFC Solver component and by supplemental components such as Unwrap Typed Rules or Collect Rules. For Typed
        Rule unwrapping it is necessary to provide all Modules so that only opposing Connectors of the same type can unwrap into valid Explicit Rules. Even non-opposing Connectors can be assigned the same type. In such case, only valid (opposing) couples
        will be unwrapped into Explicit Rules.</p>
    <p>As the Typed Rule is in fact a half-rule, it is always valid as long as it refers to an existing Module and its Connector.
    </p>
    <h5 id="8321-typed-rule-properties">8.3.2.1. Typed Rule properties</h5>
    <ul>
        <li><strong>Module Name</strong> - is the unique text identifier of the (source) Module</li>
        <li><strong>Connector Index</strong> - is the unique integer identifier of the (source) Connector of the (source) Module</li>
        <li><strong>Type</strong> - is the unique text identifier of the connection type. Two Modules with opposing connectors assigned the same connection Type can become neighbors.
        </li>
    </ul>
    <h5 id="8322-typed-rule-casts">8.3.2.2. Typed Rule casts</h5>
    <p>A Typed Rule can be cast from a text (string) that has format identical to the user-friendly Typed Rule text report: <code>module:connector = type</code>. A Typed Rule does not casts to any other data type.</p>
    <h5 id="8323-typed-rule-viewport-preview-and-baking">8.3.2.3. Typed Rule Viewport preview and baking</h5>
    <p>A Typed Rule cannot be displayed on its own. Following a precedent of Vector display component in Grasshopper, there is a Rule Preview component in Monoceros. When provided with all Modules, it displays a Typed Rule as a line between all couples of
        opposing Connectors assigned the connection Type. The color of the line indicates the direction of the connectors (and therefore also of the Rule): red means the connectors are facing X direction, green represents Y direction and blue indicates
        Z direction. In 1/3 (to prevent collision because in real-life use cases lines cross in their middle) of the line there is a dot with a text label indicating the connection Type.</p>
    <p>A Typed Rule preview can be baked.</p>
    <h4 id="833-indifferent-typed-rule">8.3.3. Indifferent Typed Rule</h4>
    <p>For convenience, Monoceros introduces a built-in Rule type: <code>indifferent</code>. When a Connector is marked Indifferent, it can connect to any other Indifferent connector of any Module. The purpose of such Typed Rule is to indicate, that the
        user does not care about specific adjacency of the given Connector and at the same time to satisfy the WFC requirement, to describe each Connector with at least one Rule.</p>
    <p>Even the indifferent Rules need to be constructed manually using the
        <a href="#1632-typed-rule">Construct Typed Rule</a> or simpler
        <a href="#17312-indifferent-rule-from-point">Indifferent Rule From Point</a>. In the usual use case, the Indifferent Rule is assigned to those Connectors, that have not been described by any other intentional Rule. For such cases, there is a shorthand
        constructor component
        <a href="#17313-indifferent-rules-for-unused-connectors">Indifferent Rules For Unused Connectors</a>.
    </p>
    <p>Just like any other Rule, Typed or Explicit, also the Indifferent Rule can be assigned to a Connector that already is described by another Rule. It can also be used as a disallowed Rule with the <a href="#1738-collect-rules">Collect Rules</a> component.
    </p>
    <h2 id="9-monoceros-wfc-solver">9. Monoceros WFC Solver</h2>
    <p>Over the course of multiple iterations (called observations) occurring internally inside the WFC Solver, Wave Function Collapse gradually changes the state of Slots from non-deterministic (allowing multiple Modules) to deterministic (allowing exactly
        one Module). This iterative process happens in the Solver component, where the Slots are observed based on pseudo-random numbers until either every Slot ends up in a deterministic state (success), or any Slot ends up in a contradictory state (failure).
        If the result is contradictory, the Solver component internally re-tries up to a predefined number of attempts, each attempt using the already modified random state and thus producing a different result each try.</p>
    <p>As mentioned earlier, Monoceros builds on top of the original <a href="#14-wave-function-collapse">Wave Function
            Collapse</a> to make it more useful for architecture and industrial design. The essence of the Monoceros extension is how it treats Modules. In original Wave Function Collapse a Module always has the dimensions to occupy exactly one Slot.
        While Monoceros Modules are aligned to the same discrete grid, they can span multiple Slots and be of any voxel-based shape as long as their Parts connect in a continuous fashion - i.e. they touch with faces and not just edges. A Monoceros Module
        Part (not available as public data type) is equivalent to a vanilla WFC Module.</p>
    <h3 id="91-rule-and-module-lowering">9.1. Rule and Module Lowering</h3>
    <p>Because it is not immediately clear how to implement a solver for Modules as defined by Monoceros, Monoceros utilizes a technique called lowering (sometimes also called desugaring) to change their representation into lower-level, vanilla WFC Modules
        and also produce metadata necessary to reconstruct the Monoceros Modules from the vanilla Modules.</p>
    <p>Even though not visible to the user, Module Parts are carefully tracked throughout the plug-in, and since Rules effectively work with Module Parts already, the Grasshopper Solver lowers the Module and Rule definitions into their low-level forms and
        feeds those into the Rust solver over the C API. After the Rust solver finishes successfully, Monoceros Modules are reconstructed from its output thanks to the backwards mapping metadata generated by lowering.</p>
    <h3 id="92-172-canonical-world-state">9.2. 1.7.2 Canonical World State</h3>
    <p>Because Monoceros allows us to modify and customize the initial state of the world and vanilla WFC has an opinion on how valid world state looks like, the Rust solver needs to detect whether the world is Canonical (valid in terms of vanilla WFC).</p>
    <p>A world is Canonical if:</p>
    <ul>
        <li>
            <p>Every Slot allows every Module (this is the initial WFC world state),</p>
        </li>
        <li>
            <p>The world is a result of applying both the observation and subsequent constraint propagation phases on an already Canonical world.</p>
        </li>
    </ul>
    <p>For example, running an observation without subsequently propagating does not produce a Canonical world and WFC does not define how this world should behave if observed or propagated any further.</p>
    <p>Setting the state of the world manually rarely produces a Canonical world. Therefore the Rust solver always Canonicalizes the world before running an observe/propagate operation. Canonicalization is implemented by starting the constraint propagation
        phase on every Slot as though it was just observed. This process can in theory be expensive, but fortunately needs to run just once per invocation of the Solver component. The Rust solver provides the information whether the world needed canonicalizing
        as part of its output.</p>
    <h2 id="10-components">10. Components</h2>
    <h3 id="101-slot-related">10.1. Slot-related</h3>
    <h4 id="1011-construct-slot-with-all-modules-allowed">10.1.1. Construct Slot With All Modules Allowed</h4>
    <h4 id="1012-construct-slot-with-listed-modules-allowed">10.1.2. Construct Slot With Listed Modules Allowed</h4>
    <h4 id="1013-deconstruct-slot">10.1.3. Deconstruct Slot</h4>
    <h4 id="1014-are-slots-boundary">10.1.4. Are Slots Boundary</h4>
    <h4 id="1015-add-boundary-layer">10.1.5. Add Boundary Layer</h4>
    <h3 id="102-module-related">10.2. Module-related</h3>
    <h4 id="1021-construct-module">10.2.1. Construct Module</h4>
    <h4 id="1022-construct-empty-module">10.2.2. Construct Empty Module</h4>
    <h4 id="1023-deconstruct-module">10.2.3. Deconstruct Module</h4>
    <h3 id="103-rule-related">10.3. Rule-related</h3>
    <h4 id="1031-construct-explicit-rule">10.3.1. Construct Explicit Rule</h4>
    <h4 id="1032-deconstruct-explicit-rule">10.3.2. Deconstruct Explicit Rule</h4>
    <h4 id="1033-is-rule-explicit">10.3.3. Is Rule Explicit</h4>
    <h4 id="1034-construct-typed-rule">10.3.4. Construct Typed Rule</h4>
    <h4 id="1035-deconstruct-typed-rule">10.3.5. Deconstruct Typed Rule</h4>
    <h4 id="1036-is-rule-typed">10.3.6. Is Rule Typed</h4>
    <h4 id="1037-unwrap-typed-rules">10.3.7. Unwrap Typed Rules</h4>
    <h4 id="1038-collect-rules">10.3.8. Collect Rules</h4>
    <h4 id="1039-explicit-rule-from-curve">10.3.9. Explicit Rule From Curve</h4>
    <h4 id="10310-typed-rule-from-point">10.3.10. Typed Rule From Point</h4>
    <h4 id="10311-rule-at-boundary-from-point">10.3.11. Rule At Boundary From Point</h4>
    <h4 id="10312-indifferent-rule-from-point">10.3.12. Indifferent Rule From Point</h4>
    <h4 id="10313-indifferent-rules-for-unused-connectors">10.3.13. Indifferent Rules For Unused Connectors</h4>
    <h3 id="104-solver">10.4. Solver</h3>
    <h4 id="1041-monoceros-wfc-solver">10.4.1. Monoceros WFC Solver</h4>
    <h3 id="105-post-processing">10.5. Post processing</h3>
    <h4 id="1051-materialize-slots">10.5.1. Materialize Slots</h4>
    <h4 id="1052-assemble-rule">10.5.2. Assemble Rule</h4>
    <h4 id="1053-rule-preview">10.5.3. Rule Preview</h4>
    <h3 id="106-supplemental">10.6. Supplemental</h3>
    <h4 id="1061-slice-geometry">10.6.1. Slice Geometry</h4>
    <h2 id="11-examples">11. Examples</h2>
    <h3 id="111-bare-minimum">11.1. Bare minimum</h3>
    <h4 id="1111-pseudo-code">11.1.1. Pseudo code</h4>
    <ul>
        <li>construct (one or) more Slots</li>
        <li>construct one or more Modules</li>
        <li>define Rules for each Connector of Each Module</li>
        <li>run Monoceros WFC Solver</li>
        <li>Materialize the result</li>
    </ul>
    <h4 id="1112-definition">11.1.2. Definition</h4>
    <p><img src="./readme-assets/bare-minimum.png" alt="Bare minimum">
        <img src="./readme-assets/bare-minimum-screenshot.jpg" alt="Bare minimum">
    </p>
    <h4 id="1113-breakdown">11.1.3. Breakdown</h4>
    <ol>
        <li><a href="#1712-construct-slot-with-listed-modules-allowed">Construct Slot With Listed Modules Allowed</a> constructs Monoceros <a href="#161-slot">Slots</a> that
            <a href="#1611-states">allows placement of any</a> Monoceros <a href="#162-module">Module</a>. Input Points collects points placed inside the created Slots. If two of such points are inside the same Slot, such Slot will be constructed twice.
            Therefore it is advised to deduplicate input points. The Output contains as many Slots as there are input points.
        </li>
        <li><a href="#1721-construct-module">Construct Module</a> constructs a single Monoceros
            <a href="#162-module">Module</a>. Input Name collects unique Module name. Input Points collects points inside Module <a href="#1621-monoceros-module-parts">Parts</a>. The points do not need to be deduplicated. Input Geometry collects geometry
            that should be <a href="#1624-orientation-and-placement">placed</a> into respective Slots by the <a href="#1751-materialize-slots">Materialize Slots</a> component.
        </li>
        <li><a href="#17313-indifferent-rules-for-unused-connectors">Indifferent Rules For Unused Connectors</a> generates <a href="#1632-indifferent-typed-rule">Indifferent Typed Rule</a> for all Module <a href="#1622-connectors">Connectors</a> from the
            Input Modules that are not described by any of the <a href="#163-rule">Rules</a> collected from the Input Rules. In this case there are no preexisting Rules, therefore all Module Connectors will be assigned an Indifferent Rule. The Output
            contains a single Rule for each unused Module Connector. For more information see the
            <a href="#181-indifferent-rules">Indifferent Rules</a> example.
        </li>
        <li><a href="#1741-monoceros-wfc-solver">Monoceros WFC Solver</a> parses the
            <a href="#1613-automatic-envelope-wrapping">Envelope</a> defined by the Input Slots, according to Input Rules that apply to Input Modules. If successful, the Output contains Slots that are <a href="#1611-states">deterministic</a> and contain
            exactly one Module.
        </li>
        <li><a href="#1751-materialize-slots">Materialize Slots</a> components places Input Modules' <a href="#1623-module-geometry">Geometry</a> into Input Slots into which they belong.
        </li>
    </ol>
    <h3 id="112-explicit-rules">11.2. Explicit Rules</h3>
    <p><a href="#831-explicit-rule">Explicit Rules</a> describe a one-to-one connection between two Module Connectors. The Connectors may come from a single or from more Modules.
    </p>
    <p>An Explicit Rule is valid when the two Connectors are opposite in the same axis (i.e. positive X connects to negative X). The validity check is only performed in components that require both, Modules and Rules as an input. Invalid Rules are being
        omitted.
    </p>
    <p>An Explicit Rule can be constructed as a literal (from Grasshopper text Panel), from its components (source and target Module and Connector Index) using
        <a href="#1031-construct-explicit-rule">Construct Explicit Rule</a> component, from a Curve connecting source and target Connector using
        <a href="#1039-explicit-rule-from-curve">Explicit Rule from Curve</a> component or with
        <a href="#10311-rule-at-boundary-from-point">Rule at boundary from Point</a> component, that <a href="#1112-choosing-boundary-modules">creates an Explicit Rule</a> connecting the Module Connector with an implicit
        <a href="#826-special-modules-out-and-empty">Out Module</a> residing outside the
        <a href="#813-automatic-envelope-wrapping">Envelope</a>.
    </p>
    <h4 id="1121-definition-explicit-rule-from-a-literal">11.2.1. Definition: Explicit Rule from a literal</h4>
    <h4 id="1122-definition-explicit-rule-from-components">11.2.2. Definition: Explicit Rule from components</h4>
    <h4 id="1123-definition-explicit-rule-from-curve">11.2.3. Definition: Explicit Rule from curve</h4>
    <h3 id="113-typed-rules">11.3. Typed Rules</h3>
    <p><a href="#1041-monoceros-wfc-solver">Monoceros WFC Solver</a>,
        <a href="#1037-unwrap-typed-rules">Unwrap Typed Rules</a> and
        <a href="#1038-collect-rules">Collect Rules</a> generate
        <a href="#831-explicit-rule">Explicit Rules</a> for all opposing Module Connectors marked with the same connection Type in the set of <a href="#832-typed-rule">Typed Rules</a>.
    </p>
    <p>A Typed Rule is valid if it refers to an existing Module and its Connectors. The validity check is only performed in components that require both, Modules and Rules as an input. Invalid Rules are being omitted.</p>
    <p>Typed Rules can be constructed from a literal (Grasshopper text Panel), from its components (name, Connector Index, connection Type) using
        <a href="#1034-construct-typed-rule">Construct Typed Rule</a>, from a Point tag (point inside the geometry of a Connector) using
        <a href="#10310-typed-rule-from-point">Typed Rule from Point</a> or with
        <a href="#114-indifferent-rules">shortcut components</a>
        <a href="#10312-indifferent-rule-from-point">Indifferent Rule from Point</a> and
        <a href="#10313-indifferent-rules-for-unused-connectors">Indifferent Rule for unused Connectors</a>. The second output of the <a href="#1022-construct-empty-module">Construct Empty Module</a> component is also a list of <a href="#1110-empty-module">Typed (Indifferent) Rules</a>.
    </p>
    <h4 id="1131-definition-typed-rule-from-a-literal">11.3.1. Definition: Typed Rule from a literal</h4>
    <h4 id="1132-definition-typed-rule-from-components">11.3.2. Definition: Typed Rule from components</h4>
    <h4 id="1133-definition-typed-rule-from-components-using-module-as-name">11.3.3. Definition: Typed Rule from components using Module as Name</h4>
    <h4 id="1134-definition-typed-rule-from-point-tag">11.3.4. Definition: {Typed Rule from Point tag</h4>
    <h3 id="114-indifferent-rules">11.4. Indifferent Rules</h3>
    <p>Indifferent Rules are ordinary Typed Rules with a predefined Type <code>indifferent</code>. It is a reserved Type because the <a href="#826-special-modules-out-and-empty">Out</a> and
        <a href="#826-special-modules-out-and-empty">Empty</a> Modules have all connectors automatically described with Indifferent Typed Rules (in case of Empty Module, the Rules need to be added manually to the Rule set). Any Connector described with
        the Indifferent Rule can connect to any opposite Connector described by an Indifferent Rule. This is mostly used for those Connectors that represent geometrical back or side (do not have a physical connector) of a Module and the user does not
        have any specific intention with them. Indifferent Connectors can be placed on the boundary of the
        <a href="#813-automatic-envelope-wrapping">Envelope</a>because the Out Module has all 6 Connectors described as Indifferent.
    </p>
    <p>The Monoceros WFC Solver requires each Module Connector to be described by at least one Rule and the Indifferent Rule is a good option for those Connectors that do not have any other purpose.</p>
    <p><strong>A connector can be described as indifferent even if it is described by another
            Explicit or Typed Rule.</strong> In most cases, only the unused Connectors are being described as Indifferent. There are several ways of constructing Indifferent Rules for unused Connectors.</p>
    <p>For the <a href="#1041-monoceros-wfc-solver">Monoceros WFC Solver</a> component you need to
        <a href="#1038-collect-rules">Collect</a> or simply Merge all Rules - the manually assigned ones with the <a href="#115-indifferent-rules">generated Indifferent</a> and Rules coming along with the <a href="#1022-construct-empty-module">Empty Module</a>.
    </p>
    <h4 id="1141-definition-indifferent-rules-for-unused-connectors">11.4.1. Definition: Indifferent Rules for unused Connectors
    </h4>
    <p><img src="./readme-assets/indifferent_rules-component.png" alt="Using component"></p>
    <h4 id="1142-definition-indifferent-rules-manual-assignment">11.4.2. Definition: Indifferent Rules manual assignment
    </h4>
    <p><img src="./readme-assets/indifferent_rules-manual.png" alt="Using component"></p>
    <h4 id="1143-definition-indifferent-rules-literal-assignment">11.4.3. Definition: Indifferent Rules literal assignment
    </h4>
    <p><img src="./readme-assets/indifferent_rules-literal.png" alt="Using component"></p>
    <h3 id="115-defining-more-modules-at-once">11.5. Defining more Modules at once</h3>
    <h4 id="1151-pseudo-code-almost-without-data-trees">11.5.1. Pseudo code: (almost) without data trees</h4>
    <ul>
        <li>construct Slots</li>
        <li>construct each Module individually with one or more Geometry</li>
        <li>define Explicit Rules from Curves</li>
        <li>define Indifferent Rules for unused Connectors</li>
        <li>merge and flatten all Rules</li>
        <li>run Monoceros WFC Solver</li>
        <li>Materialize the result</li>
    </ul>
    <h4 id="1152-definition-almost-without-data-trees">11.5.2. Definition: (almost) without data trees</h4>
    <p><img src="./readme-assets/multiple-modules-explicit-rules.png" alt="Without trees"></p>
    <h4 id="1153-pseudo-code-with-data-trees">11.5.3. Pseudo code: with data trees</h4>
    <ul>
        <li>construct Slots</li>
        <li>graft list of Module names so that each name ends up in a separate branch</li>
        <li>merge Module Part Points and graft so that each Point ends up in a separate branch (if a Module consists of multiple Parts, process the Points like the Geometry in the following steps)</li>
        <li>if one or more Modules should contain more Geometry items, group each Geometry items belonging to each Module (do this also for single Geometry items), then merge to get a list of groups and ungroup so that each list of Geometries ends up in a
            separate branch</li>
        <li>construct Modules at once using the parallel data trees of Names, Points and Geometries
        </li>
        <li>flatten the list of Modules</li>
        <li>define Explicit Rules from Curves</li>
        <li>define Indifferent Rules for unused Connectors</li>
        <li>merge and flatten all Rules</li>
        <li>run Monoceros WFC Solver</li>
        <li>Materialize the result</li>
    </ul>
    <h4 id="1154-definition-with-data-trees">11.5.4. Definition: with data trees</h4>
    <p><img src="./readme-assets/multiple-modules-tree-explicit-rules.png" alt="Without trees"></p>
    <h4 id="1155-result">11.5.5. Result</h4>
    <p><img src="./readme-assets/multiple-modules-tree-explicit-rules-a.jpg" alt="Pitchforks setup">
        <img src="./readme-assets/multiple-modules-tree-explicit-rules-b.jpg" alt="Pitchforks">
    </p>
    <h3 id="116-slots-and-module-parts-with-non-uniforms-dimensions">11.6. Slots and Module Parts with non-uniforms dimensions
    </h3>
    <p>If the Module geometry does not naturally fit into cubic grid, it is possible to define a non-uniform grid for Module Parts as well as for the Slots. The dimensions of Part and Slot are defined as a Vector representing a diagonal of the basic grid
        unit. The axial dimensions of the Vector are aligned with the Module's or Slot's Base Plane.</p>
    <p>The Diagonal also defines the discrete step of the world, in which the Modules and Slots reside. Therefore components
        <a href="#1021-construct-module">Construct Module</a>,
        <a href="#1011-construct-slot-with-all-modules-allowed">Construct Slot with all Modules allowed</a>,
        <a href="#1012-construct-slot-with-listed-modules-allowed">Construct Slot with listed Modules allowed</a> and <a href="#1061-slice-geometry">Slice Geometry</a> consider the defined Base Plane as the world origin and orientation and the Diagonal
        as the basic unit, into which they should slice the WFC data.
    </p>
    <p><strong>All Modules and Slots used in one solution must have identical Diagonal dimensions!</strong></p>
    <h4 id="1161-definition">11.6.1. Definition</h4>
    <p><img src="./readme-assets/non-uniform.png" alt="Viewport"></p>
    <h4 id="1162-result">11.6.2. Result</h4>
    <p><img src="./readme-assets/non-uniform-process.jpg" alt="Viewport">
        <img src="./readme-assets/non-uniform-result.jpg" alt="Viewport">
    </p>
    <h3 id="117-modules-and-envelope-with-individual-base-planes">11.7. Modules and Envelope with individual base planes
    </h3>
    <p>A Base Plane defines element's (Module or Slot) coordinate system origin and orientation. All their coordinates and directions will be measured from the Base Plane.
    </p>
    <p>During <a href="#1051-materialize-slots">Materialization</a> of the solution, the Module
        <a href="#823-module-geometry">Geometry</a> will be oriented from the Module Parts' Pivots (planes in the center of Module Parts aligned to the Module's Base Plane) to the respective Slot's Pivot (plane in the center of the Slot aligned to the
        common Base Plane of all Slots).
    </p>
    <p>Even though in Monoceros it is possible to set individual Base Planes for each element, <strong>all <a
                href="#81-slot">Slots</a> entering the
            Plane</strong>. The <a href="#82-module">Modules</a> can have individual Base Planes that do not
        <a href="#1041-monoceros-wfc-solver">Monoceros WFC Solver</a> must share an identical Base need to be identical across the solution.
    </p>
    <h3 id="118-disallowing-rules">11.8. Disallowing Rules</h3>
    <p>The <a href="#1041-monoceros-wfc-solver">Monoceros WFC Solver</a> only works with allowed Rules, however sometimes it may be useful to disallow certain connection. This is especially useful when <a href="#832-typed-rule">Typed</a> or
        <a href="#833-indifferent-typed-rule">Indifferent</a> Rules are being used. Such rules
        <a href="#1037-unwrap-typed-rules">unwrap</a> into one or more
        <a href="#1039-explicit-rule-from-curve">Explicit Rules</a>, out of which some may be unwanted. In such case it is possible to <strong>remove the unwanted Rules from the
            rule set using the <a href="#1038-collect-rules">Collect Rules</a> component</strong> and effectively disallowing them. If a Rule is not present in the collection of allowed Rules, it is not necessary to manually disallow it.
    </p>
    <p>To disallow a Rule, it first needs to be created. Only then it is decided, whether the Rule will be allowed or disallowed:
    </p>
    <ul>
        <li>If a Rule should be allowed, it may be passed directly into the Monoceros WFC Solver or into the Allowed Rules input (and must not be passed into the Disallowed Rules input) of the Collect Rules component.</li>
        <li>If a Rule should be disallowed, it cannot be listed in the Rule set passed directly into the Monoceros WFC Solver. To ensure its removal from the list of allowed Rules, it should be passed into the Disallowed Rules input of the Collect Rules component,
            while all allowed Rules are being passed into the Allowed Rules input. The Collect Rules component first unwraps and validates all allowed and disallowed Rules and then removes (if present) the disallowed Rules from the list of allowed Rules.</li>
    </ul>
    <p>Both, Explicit and Typed Rules can be disallowed. The Collect Rules component can be used repeatedly but in most cases it is enough to use it right before passing the Rules into the Monoceros WFC Solver because at hat time the list of all allowed
        Rules should be already complete.</p>
    <p><strong>The output of the Collect Rules component completely replaces any previous
            Rule set and should not be merged with any previous lists of Rules.</strong></p>
    <p><strong>The Monoceros WFC Solver requires all Module Connectors to be described by at
            least one Rule. Disallowing Rules may result in removing all Rules for certain
            Connectors, which makes the solution impossible. In such case the Monoceros WFC
            Solver throws an error.</strong></p>
    <h4 id="1181-definition">11.8.1. Definition</h4>
    <h3 id="119-modules-with-more-parts">11.9. Modules with more Parts</h3>
    <p>A <a href="#82-module">Module</a> can consist of more <a href="#821-monoceros-module-parts">Parts</a> which always hold together in <a href="#1051-materialize-slots">Materialized</a> result of the <a href="#1041-monoceros-wfc-solver">Monoceros WFC Solver</a>.
        Each Part should occupy one <a href="#81-slot">Slot</a> of the world <a href="#813-automatic-envelope-wrapping">Envelope</a>. The <a href="#1021-construct-module">Construct
            Module</a> component requires a list of Module Part Points inside the created Module Parts.</p>
    <p>Potential Module Parts are boxes of a size specified as
        <a href="#825-module-properties">Diagonal</a> filling the entire world, starting with a Part which has its center at the world origin defined by the Module's
        <a href="#825-module-properties">Base Plane</a>, aligned to match the Base Plane orientation. Those
        <strong>potential Parts, which contain one or more
            <a href="#1021-construct-module">Module Part Points</a> will become Parts</strong> of the created Module. It means, that even more Points may mark a single Module Part and therefore the <strong>Points do not have to be
            deduplicated</strong>.
    </p>
    <p>The Module Parts and therefore also the Module Part <strong>Points do not need to
            match the <a href="#823-module-geometry">Module Geometry</a></strong>. In many cases the Module Geometry extends, occupies only some Module Parts or does not exist at all.</p>
    <p>Module Part Points can be created manually, come from manually populated input geometry or from <a href="#1061-slice-geometry">Slice Geometry</a> component. It is advised to <strong>create the Module Part
            Points manually whenever possible</strong> because it is the conscious way, whereas the Slice Geometry component is a brute force approach with
        <a href="#1128-why-does-the-slice-geometry-component-give-invalid-results">many limitations</a> and potentially inconsistent results.
    </p>
    <p>It is advised to <strong>keep the number of Module Parts meaningfully low</strong>. Too many Parts result in slow performance of the Monoceros WFC Solver and lower probability of finding a valid solution. The current version of the Monoceros WFC Solver
        also only <strong>supports solutions with maximum of 256 Parts</strong> from all Modules together. If this number is exceeded with a single Module, the Module is marked Invalid an the user gets notified by the
        <a href="#1021-construct-module">Constructor</a> and by all components and floating parameters receiving the invalid Module. If this number is exceeded only when all Modules are passed into the Monoceros WFC Solver, the user gets notified by the
        Solver component.
    </p>
    <h4 id="1191-definition-module-part-points-created-manually">11.9.1. Definition: Module Part Points created manually
    </h4>
    <h4 id="1192-definition-module-part-points-created-manually-from-geometry">11.9.2. Definition: Module Part Points created manually from geometry</h4>
    <h4 id="1193-definition-module-part-points-created-with-slice-geometry">11.9.3. Definition: Module Part Points created with Slice Geometry</h4>
    <h3 id="1110-empty-module-and-allowing-an-empty-neighbor">11.10. Empty Module and allowing an Empty neighbor</h3>
    <p>If the Modules consist of more <a href="#821-monoceros-module-parts">Module Parts</a> it is often possible that the <a href="#82-module">Modules</a> cannot be stacked together without leaving blank <a href="#81-slot">Slots</a>, which is considered
        a
        <a href="#5-wave-function-collapse">contradictory</a> and therefore invalid result.
    </p>
    <p>Monoceros therefore introduces a convenient
        <a href="#826-special-modules-out-and-empty">Empty Module</a>
        <a href="#1022-construct-empty-module">constructor</a>. It is a shortcut for creating a Module named
        <code>empty</code> with a single <a href="#821-monoceros-module-parts">Part</a>, with no
        <a href="#823-module-geometry">Geometry</a> and all <a href="#822-connectors">Connectors</a> described as <a href="#833-indifferent-typed-rule">Indifferent</a>. Since the name <code>empty</code> of the default Empty Module cannot be changed, only
        one Empty Module can be used for a solution.
    </p>
    <p><em>Note: An Empty Module with a different name can be also constructed manually,
            which in some cases may be useful, when more types of empty Modules are
            required.</em></p>
    <p>The Rules generated by the Empty Module constructor component need to be added to the Rule set.</p>
    <p>An Empty Module does have a geometrical representation and does appear in the Rhinoceros viewport just like any other Module. Its helper geometry (cage and Connector anchor points) can be baked and used to define additional Rules involving the Empty
        Module, i.e. an Explicit Rule allowing adjacency of the Empty Module to a specific (non-indifferent) Connector or a Typed Rule.</p>
    <p><em>Note: It is advised to construct the Empty Module with a Base Plane shifted
            away from the world XY origin because in most cases there already is a custom
            module at {0,0,0} coordinate. If the Module inputs overlap, the Rules from
            Points or Curves may be mixed.</em></p>
    <p><em>Note: It is convenient to generate Explicit Rules from Curve from the desired
            Connectors to all six Connectors of the Empty Module. The Monoceros WFC Solver
            or other components will remove the invalid Rules that connect non-opposite
            Connectors.</em></p>
    <h4 id="11101-definition-empty-module-and-additional-explicit-rules">11.10.1. Definition: Empty Module and additional Explicit Rules</h4>
    <h4 id="11102-definition-explicit-rules-with-all-connectors-of-empty">11.10.2. Definition: Explicit Rules with all Connectors of Empty</h4>
    <h4 id="11103-definition-multiple-different-empty-modules">11.10.3. Definition: Multiple different Empty Modules
    </h4>
    <p>If the Empty Module should be larger than a single Part, it is convenient to generate custom Modules with no geometry with the required properties and allow them to be adjacent to the Modules that require more Empty space next to them.</p>
    <h3 id="1111-allowing-modules-to-be-at-the-boundary-of-the-envelope">11.11. Allowing Modules to be at the boundary of the Envelope</h3>
    <p>The Envelope <a href="#81-slot">Slots</a> are
        <a href="#813-automatic-envelope-wrapping">automatically wrapped</a> into a layer of Slots containing exclusively an <code>out</code> Module. It is being generated
        <a href="#826-special-modules-out-and-empty">implicitly automatically</a> in the
        <a href="#1041-monoceros-wfc-solver">Monoceros WFC Solver</a> component and in
        <a href="#1037-unwrap-typed-rules">Unwrap Typed Rules</a> and
        <a href="#1038-collect-rules">Collect Rules</a> components. The Out Module has one Part and automatically comes with all 6 connectors described as
        <a href="#833-indifferent-typed-rule">Indifferent</a>.
    </p>
    <p>This way the <a href="#826-special-modules-out-and-empty">Out Module</a> can be adjacent to itself and to all Indifferent <a href="#822-connectors">Connectors</a>. That means that all Modules with Indifferent Connectors can be at the boundary of the
        Envelope because their Indifferent Connectors can be adjacent to the Out Module, which is certainly placed outside of the Envelope.</p>
    <p>Some sets of Modules and Rule sets, however, require additional way of allowing some Modules to be at the boundary of the Envelope. THis typically happens when the Modules create an open linear (i.e. pipes) or a branching (i.e. growing tree) structure.
        Ins such case a Module that can appear in the middle of an assembly, should be also able to appear at its beginning and end - at the boundary of the Envelope. Such Module's Connector should not be described as Indifferent because then it could
        appear next to any other Indifferent Connector, which would break the structure of the aggregate. For such cases there is <a href="#10311-rule-at-boundary-from-point">Rule at boundary from Point</a> component, which creates an Explicit Rule, allowing
        adjacency of a Connector tagged with the input Point and an opposite Out Module's Connector. This is the most convenient way of creating such Rule because there is no need to specify the correct opposite Connector of the Out Module.</p>
    <p><em>Note: The Out Module module does not have any geometrical representation in the
            Rhinoceros viewport and therefore it is impossible to create an Explicit Rule
            from Curve with it.</em></p>
    <p>It is also possible to disallow certain Indifferent Module Connectors from appearing at the boundary of the Envelope by generating respective rules with the Rule at boundary from Point component and disallow them using the
        <a href="#1038-collect-rules">Collect Rules</a> component.
    </p>
    <h4 id="11111-definition">11.11.1. Definition</h4>
    <h3 id="1112-constructing-slots">11.12. Constructing Slots</h3>
    <p>Monoceros <a href="#81-slot">Slots</a> are cuboid (box-like) chunks of space, delimiting a single basic discrete gid unit, which can contain certain
        <a href="#821-monoceros-module-parts">Module Part</a>. A flat list of Slots forms an
        <a href="#813-automatic-envelope-wrapping">Envelope</a>. The Envelope can have any shape, be full or hollow, one, two or three-dimensional, form a single or multiple blobs.
    </p>
    <p>Each individual Slot is created by defining (any) point inside the respective chunk of space delimited by the potential Slot. Each input point generates one Slot, therefore
        <a href="#1114-preventing-duplicate-slots-from-points">duplicate input points</a> create duplicate Slots.
    </p>
    <p>Slot input points can be constructed either manually, manually from geometry, using the <a href="#1061-slice-geometry">Slice Geometry</a> component or employing a combination of these methods. It is advised to <strong>generate the input points
            manually or manually from geometry whenever possible</strong> because it offers better control. The Slice Geometry component is a brute force approach with
        <a href="#1128-why-does-the-slice-geometry-component-give-invalid-results">many limitations</a> and potentially inconsistent results.
    </p>
    <h4 id="11121-definition-slots-from-manually-generated-points">11.12.1. Definition: Slots from manually generated points
    </h4>
    <h4 id="11122-definition-slots-from-manually-generated-points-from-geometry">11.12.2. Definition: Slots from manually generated points from geometry</h4>
    <h4 id="11123-definition-slots-from-slice-geometry-points">11.12.3. Definition: Slots from Slice Geometry: Points
    </h4>
    <h4 id="11124-definition-slots-from-slice-geometry-curves">11.12.4. Definition: Slots from Slice Geometry: Curves
    </h4>
    <h4 id="11125-definition-slots-from-slice-geometry-surfaces">11.12.5. Definition: Slots from Slice Geometry: Surfaces
    </h4>
    <h4 id="11126-definition-slots-from-slice-geometry-mesh-and-brep-volumes">11.12.6. Definition: Slots from Slice Geometry: Mesh and Brep volumes</h4>
    <h4 id="11127-definition-slots-from-slice-geometry-miscellaneous-geometry">11.12.7. Definition: Slots from Slice Geometry: Miscellaneous geometry</h4>
    <h3 id="1113-preventing-duplicate-slots-from-points">11.13. Preventing duplicate Slots from points</h3>
    <p>Monoceros <a href="#81-slot">Slots</a> are constructed via components
        <a href="#1011-construct-slot-with-all-modules-allowed">Construct Slot with all Modules allowed</a> or
        <a href="#1012-construct-slot-with-listed-modules-allowed">Construct Slot with listed Modules allowed</a> per single Slot. That means each input point generates one Slot even if a Slot at that discrete grid position already exists. That will not
        only result in too many Slots but also cause an error of the
        <a href="#1041-monoceros-wfc-solver">Monoceros WFC Solver</a>. To prevent that, the input points need to be properly deduplicated, so that each Slot is marked by a single point, located unambiguously inside the Slot.
    </p>
    <p>This can be done manually, but more conveniently it is possible to use the
        <a href="#1061-slice-geometry">Slice Geometry</a> component to process the input collection of points into a list of distinct Slot centers.
    </p>
    <h4 id="11131-definition">11.13.1. Definition</h4>
    <h3 id="1114-allowing-certain-modules-in-certain-slots">11.14. Allowing certain Modules in certain Slots</h3>
    <p><a href="#81-slot">Slots</a> are distinct discrete cuboid chunks of space, that allow placement of certain ]<a href="#82-module">Module</a> or their
        <a href="#821-monoceros-module-parts">Parts</a> into the respective portion of space.
    </p>
    <p>In the initial state of the solution, the Slots can either allow placement of
        <a href="#1011-construct-slot-with-all-modules-allowed">any Module or its Part</a> or a specified <a href="#1012-construct-slot-with-listed-modules-allowed">list of Modules</a>. The latter is especially useful if certain areas of the Envelope
        should or should not contain certain Modules. The list of allowed Modules needs to be specified manually for each Slot, but this can be effectively achieved with the existing Grasshopper tools.
    </p>
    <h4 id="11141-definition-allowing-modules-modules-in-certain-area">11.14.1. Definition: Allowing Modules modules in certain area</h4>
    <h4 id="11142-definition-disallowing-modules-modules-in-certain-area">11.14.2. Definition: Disallowing Modules modules in certain area</h4>
    <h4 id="11143-definition-allowing-modules-modules-based-on-attractor">11.14.3. Definition: Allowing Modules modules based on attractor</h4>
    <h4 id="11144-roulette-approach-to-weighted-probability">11.14.4. Roulette approach to weighted probability</h4>
    <p>The Slots do not allow weighted probability of placing certain Modules but the weight can be simulated and distributed discretely. That means, allowing placement of a certain Module will be allowed in Slots more or less often in Slots of certain area.
        For each individual Slots there will have to be a decision to be made, whether it should or should not allow placement of a Module based on the probability factor.</p>
    <p>Technically, this can be achieved by a roulette method: a random item will be chosen from a list of possibilities but the items will be multiplied in the list based on their probability.</p>
    <h4 id="11145-definition-roulette---choosing-a-binary-weighted-option">11.14.5. Definition: Roulette - Choosing a binary weighted option</h4>
    <p>For example, the algorithm should choose from two options <code>a</code> and <code>b</code>, with probability
        <code>3:2</code> in favour of option <code>a</code>, the list of options will contain items
        <code>a, a, a, b, b</code>, out of which one random option will be chosen.</p>
    <h4 id="11146-definition-roulette---choosing-one-weighted-option-from-multiple-choices">11.14.6. Definition: Roulette - Choosing one weighted option from multiple choices</h4>
    <p>For more items, the probability can defined as a number from range <code>0.0 to 1.0</code> with probabilities
        <code>a=0.3</code>, <code>b=0.1</code>, <code>c=0.8</code>, then the list of items will contain
        <code>a, a, a, b, c, c, c, c, c, c, c, c</code>, out of which one random item will be chosen.</p>
    <h4 id="11147-definition-roulette---choosing-more-weighted-options-from-multiple-choices">11.14.7. Definition: Roulette - Choosing more weighted options from multiple choices</h4>
    <p>It the random weighted selection expects results with more items, it is possible to use the same strategy. The
        <a href="#11155-definition-roulette---choosing-a-binary-weighted-option">previous example</a> could describe a Slot, that can contain <code>3</code> Modules, witch probabilities
        <code>a=0.3</code>, <code>b=0.1</code>, <code>c=0.8</code>. The list of items will be extended to
        <code>a, a, a, b, c, c, c, c, c, c, c, c</code> and randomly reduced back to <code>3</code> options. Such result will most probably contain <code>c, c, c</code>, which then will be deduplicated to <code>c</code> or
        <code>a, c, c</code> deduplicated to <code>a, c</code>. This way it is possible to keep only the most probable modules in a Slot.
    </p>
    <h4 id="11148-definition-allowing-modules-based-on-vertical-gradient">11.14.8. Definition: Allowing Modules based on vertical gradient</h4>
    <p>Employing the
        <a href="#11157-definition-roulette---choosing-more-weighted-options-from-multiple-choices">roulette</a> approach, it is possible to use gradient values calculated from vertical position to a probability of Module placement.
    </p>
    <h4 id="11149-definition-allowing-modules-based-on-multiple-attractor-gradients">11.14.9. Definition: Allowing Modules based on multiple attractor gradients</h4>
    <p>Employing the
        <a href="#11157-definition-roulette---choosing-more-weighted-options-from-multiple-choices">roulette</a> approach, it is possible to use gradient values calculated from distance of an attractor to a probability of Module placement.
    </p>
    <h3 id="1115-fixing-modules-in-envelope-before-running-the-solver">11.15. Fixing Modules in Envelope before running the Solver</h3>
    <p>In certain cases it is desired to place certain <a href="#82-module">Modules</a> into certain <a href="#81-slot">Slots</a> even before running the
        <a href="#9-monoceros-wfc-solver">Monoceros WFC Solver</a>. The solution will then respect the position of such placed Modules and the rest of the solution will follow according to the given <a href="#83-rule">Rule</a> set.
    </p>
    <p>In Monoceros it is possible to achieve this by constructing the respective Slots with the list of Allowed Modules containing only the desired Module. If the Module consists of more <a href="#821-monoceros-module-parts">Parts</a> it is sufficient to
        construct a single Slot with the list of allowed Modules containing exclusively the desired Module. Monoceros will place one of the Module Parts into the Slot and the rest into the adjacent Slots as long as they are allowed to be place there,
        too.
    </p>
    <p><em>Note: Due to the way <a href="#9-monoceros-wfc-solver">Monoceros</a> exposes the vanilla
            <a href="#5-wave-function-collapse">Wave Function Collapse</a> algorithm, it is not
            possible to place a Module into an exact position. The
            <a href="#9-monoceros-wfc-solver">Monoceros WFC Solver</a> picks any Module Part to be
            placed into a Slot allowing placement of the Module.</em></p>
    <p><em>Note: Placing Modules manually may cause longer search for a valid solution or
            completely unable an existence of a valid solution.</em></p>
    <h3 id="1116-disallowing-certain-modules-from-certain-slots">11.16. Disallowing certain Modules from certain Slots
    </h3>
    <p>Similarly to
        <a href="#1116-fixing-modules-in-envelope-before-running-the-solver">allowing</a> certain
        <a href="#82-module">Modules</a> to be placed into certain <a href="#81-slot">Slots</a>, it is possible to disallow placement of certain Modules into certain Slots.
    </p>
    <p>Because Monoceros does not recognize disallowing, it is necessary to remove the disallowed Module name from the list of allowed modules for the respective Slots. For newly created Slots the list of allowed Modules should be prepared manually. Existing
        Slots can be <a href="#1013-deconstruct-slot">deconstructed</a> and reconstructed with a reduced list of allowed Modules. The original Slots should be replaced with the reconstructed ones.</p>
    <h4 id="11161-definition-disallowing-modules-in-new-slots">11.16.1. Definition: Disallowing Modules in new Slots
    </h4>
    <h4 id="11162-definition-disallowing-modules-in-existing-slots">11.16.2. Definition: Disallowing Modules in existing Slots
    </h4>
    <h3 id="1117-enforcing-specific-modules-at-the-boundary-of-the-envelope">11.17. Enforcing specific modules at the boundary of the Envelope</h3>
    <p>If specific <a href="#82-module">Modules</a> are
        <a href="#1111-allowing-modules-to-be-at-the-boundary-of-the-envelope">allowed to be placed at the boundary of
            the Envelope</a> but their placement should be enforced, it is possible to identify
        <a href="#81-slot">Slots</a> at the boundary of the
        <a href="#813-automatic-envelope-wrapping">Envelope</a> using the
        <a href="#1014-are-slots-boundary">Are Slots Boundary</a> component,
        <a href="#1013-deconstruct-slot">deconstructing</a> the boundary Slots and
        <a href="#1114-allowing-certain-modules-in-certain-slots">allowing</a> or
        <a href="#1116-disallowing-certain-modules-from-certain-slots">disallowing</a> the desired Modules from these Slots.
    </p>
    <h4 id="11171-definition">11.17.1. Definition</h4>
    <h4 id="11172-definition-identifying-more-boundary-layers">11.17.2. Definition: Identifying more boundary layers
    </h4>
    <p>If more than one boundary layer of <a href="#81-slot">Slots</a> should be isolated, the
        <a href="#1014-are-slots-boundary">Are Slots Boundary</a> component can be used multiple times, each time on Slots identified as inner (non-boundary).
    </p>
    <h3 id="1118-growing-the-boundary-of-the-envelope">11.18. Growing the boundary of the Envelope</h3>
    <p>It is possible to wrap the existing
        <a href="#813-automatic-envelope-wrapping">Envelope</a> of <a href="#81-slot">Slots</a> into another layer of Slots. The <a href="#1015-add-boundary-layer">Add Boundary Layer</a> component generates a collection of <a href="#812-slot-properties">Slot center points</a>        that can be converted into Slots, which will form a single added layer to the existing Envelope.
    </p>
    <h4 id="11181-definition">11.18.1. Definition</h4>
    <h3 id="1119-materializing-results">11.19. Materializing results</h3>
    <p>A correct result of the <a href="#9-monoceros-wfc-solver">Monoceros WFC Solver</a> is a collection of deterministic <a href="#81-slot">Slots</a>, which allow exactly one
        <a href="#821-monoceros-module-parts">Module Part</a> to be placed. This is still not the final stage of the discrete assembly process because the solution is not yet
        <a href="#1051-materialize-slots">Materialized</a>, which is a process of placing
        <a href="#823-module-geometry">Module Geometry</a> into its respective Slots.
    </p>
    <p>The output of <a href="#1051-materialize-slots">Materialize Slots</a> component is a data tree with paths
        <code>{ module index, slot index }</code>, where <code>module index</code> is the order of the placed Module in the input list of Modules and
        <code>slot index</code> is the order of the target Slot in the input list of Slots. Each branch then contains all geometry items of the respective Module.
    </p>
    <p><em>Note: Due to the way Monoceros treats Module Parts, only the first Part of each
            Module is placed into its Slot, leaving the remaining Slots containing the
            Module empty (their index will not even appear in the Materialize Slots
            component output data tree).</em></p>
    <p>The geometry output of the Materialize Slots component is intended for further use in Grasshopper. Therefore, if the intention is to bake the output of the WFC already in this stage, it is advised to bake the Materialize Slots component. The result
        of such bake is a
        <a href="#128-are-block-instances-or-groups-supported-by-monoceros">collection of block instances</a>, which are significantly smaller than full-fledged geometry and all blocks of one type can be edited at once.
    </p>
    <p><em>Note: The viewport rendering of materialized geometry may be slow on some
            computers. This makes the Materialize Slots component one of the slowest part of
            a Grasshopper Monoceros definition. To speed it up, it is recommended to disable
            preview of the Materialize Slots component prior to connecting wires to its
            inputs.</em></p>
    <h4 id="11191-definition">11.19.1. Definition</h4>
    <h3 id="1120-proto-results-and-custom-materialization">11.20. Proto-results and custom materialization</h3>
    <p>In some cases the final geometry of a Grasshopper definition does not have to be
        <a href="#823-module-geometry">the one stored</a> in the Monoceros <a href="#82-module">Modules</a>. The Modules can contain some proto=geometry instead and the final geometry is then constructed in Grasshopper after
        <a href="#1051-materialize-slots">materialization</a>.
    </p>
    <p>A typical case may be structures that are not meant to be discrete, but rather continuous. The Modules should then contain only the skeleton of such structure, which will be joined and wrapped into volumes after the materialization of the WFC assembly.</p>
    <h4 id="11201-definition">11.20.1. Definition</h4>
    <h3 id="1121-using-the-transform-data-to-materialize-the-result">11.21. Using the transform data to materialize the result
    </h3>
    <p>In very special cases, the geometry does not have to enter the
        <a href="#82-module">Modules</a> at all. Instead, the
        <a href="#9-monoceros-wfc-solver">Monoceros WFC Solver</a> runs on the <a href="#83-rule">Rule</a> set an Modules with no <a href="#823-module-geometry">geometry</a> and so does the
        <a href="#1051-materialize-slots">Materialize Slots</a> component. Its <code>Transform</code> output contains transformation data, that can be used to place any geometry from the original Module location into all the <a href="#81-slot">Slots</a>        which should contain the respective geometry.
    </p>
    <p>This is especially useful if there are various geometry sets that could be used as the Module Geometry. These sets can be interchanged without the need of recalculating the entire Monoceros WFC solution.</p>
    <p><em>Note: The geometry that should be placed using the <code>Transform</code> output needs to
            be located and aligned properly: it should share the same location and Base
            Plane orientation with the original Module.</em></p>
    <h4 id="11211-definition">11.21.1. Definition</h4>
    <h3 id="1122-random-seed-and-attempts-count">11.22. Random seed and attempts count</h3>
    <p>During the <a href="#5-wave-function-collapse">Wave Function Collapse</a> calculation, there are several moments when a random decision has to be made: if a
        <a href="#81-slot">Slot</a> allows placement a equally valid <a href="#82-module">Modules</a>, the
        <a href="#9-monoceros-wfc-solver">Monoceros WFC Solver</a> chooses one random Module to be placed. Such situation can occur at several Slots at a time, therefore the Solver chooses a random Slot to process.
    </p>
    <p>Like Grasshopper, also Monoceros uses seeded pseudo-random function. That means that the <strong><a
                href="#1041-monoceros-wfc-solver">Monoceros WFC Solver</a> generates the same
            solution for a constant <a href="#83-rule">Rule</a> set and constant Modules and Slots
            every time and at every computer, as long as the seed is the same</strong> and vice versa, <strong>different
            seeds generate different outputs</strong> even on the same computer.</p>
    <p>The WFC algorithm does not ensure there will always be a solution. Throughout the processing it can happen that the setup may not result in a valid output - some Slots may end up contradictory and allow placement of no Modules whatsoever. Such situation
        cannot be anticipated rr prevented, therefore it is necessary to make several attempts with different random decisions. The
        <a href="#1041-monoceros-wfc-solver">Monoceros WFC Solver</a> component lets the user to define how many unsuccessful attempts should it make until it pronounces the setting unsolvable.
    </p>
    <p><strong>There is no good value for maximum attempts.</strong> For simple and well defined setups the Solver usually finds the solution in the first attempt but it is not rare that it takes more than a thousand attempts to find a solution in some cases.
        The mere fact that it requires <strong>more than one attempt shows, that the
            setup is problematic</strong> and may not be solvable at all.</p>
    <p><strong>There is no good value for the random seed.</strong> Changing the random seed for setups that produce solutions will result in various, yet equally good solutions. The properties and qualities of a solution are not related to the value of
        the random seed, therefore it makes no sense to compare one seed to another. For solutions that are hard to find it may happen, that for some random seeds the Solver requires less attempts than for others. This is only true until other inputs
        (Modules, Rules and Slots) remain unchanged.</p>
    <h3 id="1123-visualizing-rules">11.23. Visualizing Rules</h3>
    <p>The <a href="#83-rule">Rules</a> can be
        <a href="#8313-explicit-rule-viewport-preview-and-baking">displayed</a> in Rhinoceros viewport and baked using
        <a href="#1053-rule-preview">Rule Preview</a> component. The Rule is shown as a line, connecting two <a href="#822-connectors">Connectors</a> that are allowed to be adjacent.
    </p>
    <p>The color of the preview line indicates the orientation of the Connectors: red means X, green means Y and blue means Z. If the Rule allowing adjacency is
        <a href="#832-typed-rule">Typed</a>, the line carries also a label with the Type name.
    </p>
    <p><em>Note: It is not always necessary to display all Rules or Rules for all
            <a href="#82-module">Modules</a>. The inputs can vary depending on the information that
            should be displayed.</em></p>
    <h4 id="11231-definition">11.23.1. Definition</h4>
    <h3 id="1124-visualizing-allowed-module-couples">11.24. Visualizing allowed Module couples</h3>
    <p>An <a href="#83-rule">Explicit Rule</a> can be displayed also as an <a href="#1052-assemble-rule">assembly</a> of two <a href="#82-module">Modules</a> that are allowed to be adjacent.</p>
    <p><em>Note: A <a href="#832-typed-rule">Typed Rule</a> can be converted into a collection of
            Explicit Rules prior to assembling.</em></p>
    <p>The Module mentioned in the <a href="#83-rule">Rule</a> first is considered a source, the second one a target. The source Module's <a href="#825-module-properties">Pivot</a> is aligned to the assembly Base Plane, the target Module is aligned to source
        Module so that their adjacent <a href="#822-connectors">Connectors</a> are touching.</p>
    <p><em>Note: The <a href="#1052-assemble-rule">Assemble Rule</a> component does not check the two
            modules for overlapping but the
            <a href="#5-wave-function-collapse">architecture of the WFC Solver</a> prevents the
            overlaps in the actual solution.</em></p>
    <p>If more Rules should be assembled at once, it is necessary to define an individual Base Plane for each assembly. The Base Planes need to be manually distributed so that the assemblies do not overlap.</p>
    <h4 id="11241-definition-visualizing-one-module-couple">11.24.1. Definition: Visualizing one Module couple</h4>
    <h4 id="11242-definition-visualizing-a-catalog-of-module-couples">11.24.2. Definition: Visualizing a catalog of Module couples</h4>
    <h2 id="12-faq">12. FAQ</h2>
    <h3 id="121-what-is-a-good-exercise-to-start-using-monoceros">12.1. What is a good exercise to start using Monoceros?
    </h3>
    <p>The Wave Function Collapse is a very powerful tool but requires a lot of patience to learn. It is recommended to read the
        <a href="https://issuu.com/subdigital/docs/wfc_book_pages">Subdigital WFC Book</a> and understand the principles of <a href="#5-wave-function-collapse">WFC</a> and its implementation in <a href="#9-monoceros-wfc-solver">Monoceros</a> before trying
        the first experiments in Grasshopper. It is especially important to understand that WFC is not a growth algorithm and how does it differ from other seemingly similar discrete assembly tools.
    </p>
    <p>When learning Monoceros and building intuitive sensitivity, the following steps are advised:</p>
    <ol>
        <li>Start as simple as possible</li>
        <li>Do not jump to complex setups too early</li>
        <li>Use a relatively small sphere to generate the
            <a href="#813-automatic-envelope-wrapping">Envelope</a>
        </li>
        <li>Try defining a single simple <a href="#82-module">Module</a> - a vertical line</li>
        <li>Generate <a href="#114-indifferent-rules">Indifferent Rules</a> for all its
            <a href="#822-connectors">Connectors</a>
        </li>
        <li>Use the <a href="#1041-monoceros-wfc-solver">Monoceros WFC Solver</a> and
            <a href="#1051-materialize-slots">Materialize Slots</a> components to finish
            <a href="#111-bare-minimum">the simplest assembly</a>
        </li>
        <li>Define the first <a href="#831-explicit-rule">Explicit Rule</a> allowing the Module to meaningfully connect to itself - bottom to the top or vice versa</li>
        <li>Try to figure out why there is
            <a href="#122-what-does-the-error-world-state-is-contradictory-mean">no solution</a>
        </li>
        <li><a href="#1111-allowing-modules-to-be-at-the-boundary-of-the-envelope">Allow the Module</a> to be placed at the <a href="#10311-rule-at-boundary-from-point">Envelope boundary</a></li>
        <li>Add <a href="#1110-empty-module-and-allowing-an-empty-neighbor">Empty Module</a></li>
        <li>Add second Module - a horizontal line</li>
        <li>Figure out why does it
            <a href="#1111-allowing-modules-to-be-at-the-boundary-of-the-envelope">not appear in the solution</a>
        </li>
        <li>Try removing the Empty Module</li>
        <li>Add the third Module - an L shape that could connect the vertical and horizontal Module</li>
        <li>Construct Explicit Rule that connects the L Module with the other two Modules
        </li>
        <li>Try preventing the vertical and horizontal Modules to appear at the boundary and place the L Module there instead
        </li>
        <li>Add the Empty Module again</li>
        <li>Add an three other L shape Modules so that the Solver can generate closed rectangles
        </li>
        <li>Try to <a href="#10311-rule-at-boundary-from-point">figure out</a> why there are open shapes and prevent them
        </li>
        <li>Try creating a Rule set that generates closed zig-zag shapes</li>
        <li>Try replacing all Explicit Rules with <a href="#832-typed-rule">Typed Rules</a></li>
        <li>Whenever hesitating, look for an answer in the <a href="#11-examples">Examples</a>.</li>
    </ol>
    <h3 id="122-what-does-the-error-world-state-is-contradictory-mean">12.2. What does the error &quot;World state is contradictory&quot; mean?</h3>
    <p>It means there is no potential solution for the current setup. It can have several reasons:</p>
    <ul>
        <li>the <a href="#821-monoceros-module-parts">Module Parts</a> form a shape that cannot be assembled without an
            <a href="#1022-construct-empty-module">Empty Module</a></li>
        <li>the <a href="#813-automatic-envelope-wrapping">Envelope</a> or <strong>its part</strong> is too small to place any allowed <a href="#82-module">Module</a></li>
        <li>no Module is allowed to be
            <a href="#1111-allowing-modules-to-be-at-the-boundary-of-the-envelope">placed at the boundary</a> because the required <a href="#822-connectors">Connectors</a> are described by custom
            <a href="#83-rule">Rules</a> and the <a href="#833-indifferent-typed-rule">Indifferent Rules</a> were not
            <a href="#1141-definition-indifferent-rules-for-unused-connectors">automatically generated</a> for them
        </li>
        <li>the <a href="#83-rule">Rule set</a> does not allow for any viable assembly</li>
    </ul>
    <h3 id="123-why-the-solver-cannot-find-any-solution-even-after-1000-attempts">12.3. Why the Solver cannot find any solution even after 1000 attempts?</h3>
    <p>Most probably because the <a href="#83-rule">Rule set</a> is too specific and the solution is rare. Try making the <a href="#813-automatic-envelope-wrapping">Envelope</a> significantly smaller without causing a a
        <a href="#122-what-does-the-error-world-state-is-contradictory-mean">contradictory world state</a> and increase the number of attempts.
    </p>
    <p>Try <a href="#1122-random-seed-and-attempts-count">changing the random seed</a>, even though it only forces the
        <a href="#9-monoceros-wfc-solver">Monoceros WFC Solver</a> to try different random set of attempts.</p>
    <p>If there is no solution even after 5000 attempts and several different random seeds, it is recommended to start over and build up the setup
        <a href="#82-module">Module</a> by Module.
    </p>
    <p>It is also possible that the setup has no solution at all.</p>
    <h3 id="124-what-makes-a-good-module">12.4. What makes a good Module?</h3>
    <p>The safest <a href="#82-module">Module</a> has only one
        <a href="#821-monoceros-module-parts">Part</a> but such Modules also generate unsurprising and simple outputs. A Module can consist of
        <a href="#825-module-properties">maximum 256</a> Parts, but it is recommended to keep the number of Module Parts under 10.
    </p>
    <p>The Module has to be <a href="#825-module-properties">consistent</a> and all its
        <a href="#822-connectors">Connectors</a> need to be described by at least one
        <a href="#83-rule">Rule</a>, even if it should be an
        <a href="#833-indifferent-typed-rule">Indifferent Rule</a>.
    </p>
    <p>To achieve interesting results, the Module's content (in most cases its
        <a href="#823-module-geometry">Geometry</a>) should be semantically heterogenous or in other words, the boundaries of semantical parts should not match the boundaries of Modules. Said simply, the whole should be cut through the middle of a distinct
        part, rather than along its boundary. If the Modules should represent urban elements, they should not contain individual houses but rather a part of a house, part of a garden, part of a pavement and a bit of a road. If the WFC should compose a
        world map, <strong>good Modules are those that contain a coast
            line</strong>, not those that contain only the sea or the land.
    </p>
    <h3 id="125-what-makes-a-good-envelope">12.5. What makes a good Envelope?</h3>
    <p>A good <a href="#813-automatic-envelope-wrapping">Envelope</a> is aware of the size and shape of the <a href="#82-module">Modules</a> that should be placed into it.</p>
    <p>If the Modules do not <a href="#124-what-makes-a-good-module">allow it</a>, the Envelope should not have small parts sticking out, forming
        <a href="#11125-definition-slots-from-slice-geometry-surfaces">thin shells</a> otherwise already the inital state of the Envelope may be
        <a href="#122-what-does-the-error-world-state-is-contradictory-mean">contradictory</a>.
    </p>
    <h3 id="126-why-does-the-slice-geometry-component-give-invalid-results">12.6. Why does the Slice Geometry component give invalid results?</h3>
    <p>If the <a href="#1061-slice-geometry">sliced geometry</a> or its part reaches the boundary, edge or vertex of a potential <a href="#81-slot">Slot</a> or a
        <a href="#821-monoceros-module-parts">Module Part</a>, it means that the part may belong into two (if on surface), four (if on edge) or even eight (if on vertex) neighboring grid cells. It is difficult for the component to decide into which one
        it should be placed. Any approach would be only approximating and could give wrong results in edge cases.
    </p>
    <p>Therefore the <a href="#1061-slice-geometry">Slice Geometry</a> component completely resigns on any decision making in unambiguous situations. Therefore it is strongly recommended to generate <a href="#1112-constructing-slots">Slot Points</a> and
        <a href="#119-modules-with-more-parts">Module Part Points</a> manually whenever possible.
    </p>
    <h3 id="127-how-to-set-a-rule-for-a-module-distant-two-or-more-slots">12.7. How to set a Rule for a Module distant two or more Slots?</h3>
    <p><strong>It is not possible.</strong> The
        <a href="#9-monoceros-wfc-solver">Monoceros Wave Function Collapse implementation</a> allows to specify only <a href="#83-rule">immediate adjacency</a>.
    </p>
    <p>For specific cases of 1D and 2D aggregates it is possible to use the remaining dimension to specify <a href="#82-module">Modules</a> with no
        <a href="#823-module-geometry">Geometry</a> spanning over more
        <a href="#821-monoceros-module-parts">Parts</a> / <a href="#81-slot">Slots</a> with <a href="#83-rule">Rules</a> at <a href="#822-connectors">Connectors</a> farther apart.
    </p>
    <h3 id="128-are-block-instances-or-groups-supported-by-monoceros">12.8. Are block instances or groups supported by Monoceros?
    </h3>
    <p><strong>No.</strong> These data types are not part of the usual geometrical hierarchy in Grasshopper.
    </p>
    <p><a href="#1021-construct-module">Construct Module</a> and
        <a href="#1061-slice-geometry">Slice Geometry</a> components support the following geometry types and their derivatives:
    </p>
    <ul>
        <li>Point</li>
        <li>Curve (and Line, Arc, Circle etc.)</li>
        <li>Surface (and Sphere etc.)</li>
        <li>Brep / Polysurface (and Box etc.)</li>
        <li>Mesh</li>
    </ul>
    <p>The
        <a href="#7-architecture-of-monoceros-grasshopper-plug-in">architecture of Monoceros</a> expects a small number of lightweight <a href="#82-module">Modules</a>. In such case it should not be a performance problem to embed the
        <a href="#823-module-geometry">geometry</a> into the Modules. The geometry itself is not being used for any calculations until the Modules reach the
        <a href="#1051-materialize-slots">Materialize Slots</a> component.
    </p>
    <p>Two things are happening in the Materialize Slots component:</p>
    <ul>
        <li>it outputs the Module Geometry in a data tree. Each branch path represents
            <code>{ module index, slot index}</code>, where <code>module index</code> is the order in which the Modules were passed into the Materialize Slots component and <code>slot index</code> is the order in which the Slots were passed into the Materialize
            Slots component. Each branch contains a complete list of geometry brought by the respective Module into its Slot. <em>Note: Only the Slots containing the first
                <a href="#821-monoceros-module-parts">Part</a> of each Module contain the Module Geometry
                to prevent duplicate geometry entries for multi-part Modules.</em> Displaying all materialized geometry in Rhinoceros viewport may be slow, therefore <strong>it is
                recommenced to disable preview for the Materialize Slots component</strong>. The output geometry may be used for further Grasshopper processing or evaluation.
        </li>
        <li>it bakes the module geometry as block instances. This means the geometry exists in Rhinoceros only once and all its instances are just references to the original block. This way it is possible to modify all instances of geometry of each Module
            type at once by modifying any of the blocks. In most cases it also means a significantly smaller Rhinoceros
            <code>.3dm</code> file.</li>
    </ul>
    <h2 id="13-partners">13. Partners</h2>
    <p>Developed at <a href="https://sub.digtial">Subdigital</a>.</p>
    <p>Supported using public funding by Slovak Arts Council.</p>
    <p><img src="./readme-assets/fpu.jpg" alt="FPU"></p>
    <h2 id="14-mit-license">14. MIT License</h2>
    <p>Copyright (c) 2021 Subdigital | Ján Pernecký, Ján Tóth</p>
    <p>Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the &quot;Software&quot;), to deal in the Software without restriction, including without limitation the rights to use,
        copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:</p>
    <p>The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.</p>
    <p>THE SOFTWARE IS PROVIDED &quot;AS IS&quot;, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT
        HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
    </p>

</body>

</html>